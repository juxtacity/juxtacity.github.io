<html>

<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap" rel="stylesheet">
    <title>Game</title>
    <link rel="icon" type="image/png" href="https://codehs.com/uploads/33edcc0f67d8eef4c7feeda8356fa3a8">
    <script src="gameValues.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
        }

        input {
            color: black
        }

        body {
            margin: 0px;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        /*
z-indexes below zero are for canvas elements
anything above that is for menus
*/
        #canvases {
            display: none;
        }

        canvas {
            position: absolute
        }

        #wcanvas {
            z-index: -1.9;
        }

        #uicanvas {
            z-index: -1;
        }

        #canvas {
            z-index: -2;
        }

        #miniMap {
            z-index: -1.1;
            opacity: 0;
        }

        #pauseMenu * {
            position: relative;
            margin-top: 0px;
            margin-bottom: 0px;
        }

        #pauseMenu {
            z-index: 3;
            margin: 20%;
            display: none;
            position: relative;
            background-color: #9494FF;
        }

        #startMenu {
            z-index: 3;
            display: block;
            text-align: center;
        }

        #startMenu * {
            position: relative;
            margin-top: 0px;
            margin-bottom: 0px;
        }

        #progressBar {
            background-color: white;
            width: 100%;
            height: 20px;
        }

        #loadingMenu {
            bottom: 50;
            width: 100%;
            text-align: center;
            opacity: 0;
            z-index: 100;
        }

        #loadingMenu * {
            text-align: center;
        }

        #progressBar * {
            background-color: red;
            height: 20px;
        }

        .inGameMenu {
            display: none;
            z-index: 2.5;
            bottom: 40px;
            background-color: black;
        }

        .inGameMenu table {
            margin-left: auto;
            margin-right: auto;
        }

        .inGameMenu * {
            position: relative;
        }

        .page {
            padding: 10vw;
            display: none;
            width: 80vw;
            height: auto;
            margin: auto;
        }

        *[type="button"] {
            display: block;
            padding: 15px 25px;
            font-size: 24px;
            cursor: pointer;
            text-align: center;
            text-decoration: none;
            outline: none;
            color: #fff;
            background-color: #2e4c65;
            border: none;
            border-radius: 4px;
            box-shadow: 0 9px #999;
        }

        *[type="button"]:hover {
            background-color: #456e89
        }

        *[type="button"]:active {
            background-color: #222851;
            box-shadow: 0 5px #666;
            transform: translateY(4px);
        }

        .page h1 {
            text-align: left;
        }
    </style>
</head>

<body id="body">

    <span id="canvases">
        <canvas id="canvas"></canvas>
        <canvas id="wcanvas"></canvas>
        <canvas id="miniMap"></canvas>
    </span>
    <canvas id="uicanvas"></canvas>

    <div id="dontActualyOpenAPage" class="page"></div>
    <div id="startMenu" class="page center">
        <h1>
            Saber Balistic
        </h1>
        <input type="button" value="Start" onclick="start(false)"><br>
        <input type="button" value="Options" onclick="openPage('optionMenu')"><br>
    </div>

    <div id="optionMenu" class="page center">
        <h1>
            Options
        </h1>
        <input type="button" value="Controls" onclick="openPage('controlMenu')"><br>
        <input type="button" value="Saves and Game Files" onclick="openPage('saveMenu')"><br>
        <input type="button" value="Back" onclick="openPage('startMenu')"><br>
    </div>

    <div id="controlMenu" class="page center">
        <h1>
            Controls
        </h1>
        <input type="button" value="Back" onclick="openPage('optionMenu')"><br>
    </div>

    <div id="saveMenu" class="page center">
        <h1>
            Saving and stuff
        </h1>
        <p>
            This game uses cookies to save your data. Now, cookies are nice, but they aren't actually very reliable. if
            you want to make sure that your game is saved, then you can copy the cookie onto a separate document using
            the copy cookie button, then when you want to use it again you can paste it into the load cookie box
        </p>
        <input type="button" value="Get Save Data" onclick="openPage('getCookieMenu'); getSaveData()"><br>
        <input type="button" value="Enter Save Data" onclick="openPage('enterCookieMenu')"><br>
        <input type="button" value="Back" onclick="openPage('optionMenu')"><br>
    </div>

    <div id="enterCookieMenu" class="page">
        <h1>
            Enter Your Data
        </h1>
        <p>
            or enter a secret code, which may or may not exist :)
        </p>
        <input type="text" id="cookieInput"><br>
        <p>
            Optional lifetime for the cookie, (how long before it deletes itself) default is 1000 days
        </p>
        <input type="number" id="cookieLifeInput" value=1000><br>

        <input type="button" value="Enter Save Data" onclick="setSaveData()"><br>
        <input type="button" value="Back" onclick="openPage('saveMenu')"><br>
    </div>

    <div id="getCookieMenu" class="page center">
        <h1>
            Your Save will appear here:
        </h1>
        <p id="dataString"></p>
        <input type="button" value="Back" onclick="openPage('optionMenu')"><br>
    </div>

    <span id="loadingMenu" class="ingameMenu">
        <div id="progressBar">
            <div id="barPart"></div>
        </div>
        <p id="proDes"></p>
        <img src="https://codehs.com/uploads/158545425e78c584e87a7a47dbda3b2f">
    </span>

    <span id="pauseMenu" class="inGameMenu">
        <h5>Enable right clicks <input type="checkbox" id="enableRightClick" name="enableRightClick" value="rightClick">
        </h5>
        <p>This will Enable the context menu for the page, I have it disabled by default because I assume that if you
            are playing a game you
            don't want to accidentaly inspect the page, but if you do then you should check this box.</p>
        <h5>No Custom Mouse<input type="checkbox" id="customMouse" name="enableRightClick" value="rightClick"></h5>
        <p>If it troubles you that there is a custom mouse instead of the regular one, then this setting is for you.</p>
        <h5>Disable Screen Shake <input type="checkbox" id="disableScreenShake" name="disableScreenShake"
                value="rightClick"></h5>
        <p>I think that screen shake is kind of cool, but if you don't like it you can turn it off.</p>
        <h5>No Gore<input type="checkbox" id="gore" name="disableScreenShake" value="rightClick"></h5>
        <p>Disables the blood splats that appear.</p>
        <h5>Friendly Gore<input type="checkbox" id="cartoonGore" name="disableScreenShake" value="rightClick"></h5>
        <p>Makes the blood splats that apear be blue so that it's not really blood.</p>
    </span>

    <span id="gunPickup" class="inGameMenu">
        <table>
            <tr>
                <td><canvas id="leftGunCanvas"></canvas></td>
                <td><canvas id="rightGunCanvas"></canvas></td>
                <td><canvas id="backupGunCanvas"></canvas></td>
                <td><canvas id="swapGunCanvas"></canvas></td>
            </tr>
            <tr>
                <td><input type="button" value="Swap left gun" onclick="changeItem('left')"></td>
                <td><input type="button" value="Swap right gun" onclick="changeItem('right')"></td>
                <td><input type="button" value="Swap backup gun" onclick="changeItem('backup')"></td>
                <td><input type="button" value="Don't pick up" onclick="changeItem('cancel')"></td>
            </tr>
        </table>
    </span>

    <span id="statUp" class="inGameMenu">
        <table>
            <tr>
                <td>
                    <p id="sneakStat"></p>
                </td>
                <td>
                    <p id="arsonStat"></p>
                </td>
                <td>
                    <p id="healthStat"></p>
                </td>
            </tr>
            <tr>
                <td><input type="button" value="Upgrade Stealth" onclick="statUp('sneak')"
                        style="backGround-color:#2789cd"></td>
                <td><input type="button" value="Upgrade Arson" onclick="statUp('arson')"
                        style="backGround-color:#f1641f"></td>
                <td><input type="button" value="Upgrade Health Insurance" onclick="statUp('health')"
                        style="backGround-color:#c4f129"></td>
            </tr>
        </table>
    </span>

</body>

<script>

    function setCookie(cname, cvalue, exdays) {
        const d = new Date();
        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
        let expires = "expires=" + d.toUTCString();
        document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
    }

    function getCookie(cname) {
        let name = cname + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }

    function getSaveData() {
        let data = getCookie("saveData")
        document.getElementById("dataString").innerHTML = data || "Looks like you don't have any data saved"
    }

    function setSaveData() {
        let data = document.getElementById("cookieInput").value
        let cookieLifeTime = document.getElementById("cookieLifeInput").value

        if (data != undefined) {
            setCookie("saveData", data, cookieLifeTime || 1000)
        }
    }

    function openPage(pageToOpenID) {
        pagesToClose = document.getElementsByClassName('page');
        for (i = 0; i < pagesToClose.length; i++) {
            pagesToClose[i].style.display = "none"
        }
        pageToOpen = document.getElementById(pageToOpenID)
        pageToOpen.style.display = "block"
    }

    function changeItem(itemToChange) {
        if (itemToChange != "cancel") {
            inventory[itemToChange].value = gunBeingPickedUp
            inventory[itemToChange].type = "gun"
        }
        closeMenu(gunPickupMenu)
    }

    function statUp(statUp) {
        lStats[statUp]++
        prevMaxHealth = player.maxHealth
        player.maxHealth = Math.pow(100, Math.sqrt(lStats.sneak * 0.01) + Math.sqrt(lStats.arson * 0.008) + Math.sqrt(lStats.health * 0.015) + 1)
        player.health *= player.maxHealth / prevMaxHealth
        statUpPause = false
        closeMenu(statUpMenu)
    }

    function closeMenu(menu) {
        paused = false
        menu.style.display = "none"
        body.style.cursor = "none"
    }

    function openMenu(menu) {
        paused = true
        menu.style.display = "inline"
        body.style.cursor = "auto"
    }
    //Audio declarations:
    //audio from https://freesound.org/people/LukeWSkywalker/sounds/581398/
    let playerWalkAudio = new Audio('player_walk_2.wav');

    //audio from https://freesound.org/people/Hardance/sounds/86089/
    let prismlightAudio = new Audio('prismlight.wav');

    //audio from https://freesound.org/people/Claiber7901/sounds/544677/
    let shotgunAudio = new Audio('shotgun.mp3');

    let statUpPause = false
    let gunPickupMenu = document.getElementById("gunPickup")
    let statUpMenu = document.getElementById("statUp")
    let loadingMenu = document.getElementById("loadingMenu")
    let progress = 0;
    let lastRender = 0;
    let objectsCanvas = document.createElement('canvas');
    let objects = makeContext(objectsCanvas, true);
    // Gun Stuff ----------------------------------------------------------------------------

    let lStats = { sneak: 0, arson: 0, health: 0, }

    let gunValues = [
        {
            stats: [1, 1, 1],
            name: "Phlazinator",
            get damage() { return getStats(this.stats) },
            get knockBack() { return Math.random() * 40 },
            fireRate: 0.3,
            shake: 4,
            energyAdd: 65,
            energy: 150,
        },// 0 Phlazinator              sneak
        {
            stats: [0, 1, 0],
            name: "spruzzler",
            ammo: 3,
            damage: 1.5,
            get knockBack() { return Math.random() * 30 },
            fireRate: 0.4,
            offSet: 0.2,
            get bulletsPerShot() { return Math.ceil(getStats(this.stats) / 2) },
            shake: 6,
            recoil: 12,
            energyAdd: 125,
        },// 1 spruzzler                arson
        {
            stats: [1, 0, 0],
            name: "Rick-oh-Shay",
            get damage() { return getStats(this.stats) / 3.3 },
            knockBack: 22,
            collision: "bulletBouncy",
            get bounce() { return getStats(this.stats) },
            shake: 3,
            energyAdd: 75,
            fireFunction(gunNumber, units, rot) {
                hot = defaultFireFunction(gunNumber, units, rot)
                hot.onCollision = bouncyBulletCollision
            },
        },// 2 rick o' shay             sneak
        {
            stats: [0, 0, 1],
            name: "M.A.A.T.i.C.K.a.a.R",
            damage: 1.5,
            get knockBack() { return Math.random() * 50 },
            fireRate: 0.5,
            size: 15,
            get pierce() { return getStats(this.stats) },
            shake: 7,
            energyAdd: 25,
        },// 3 M.A.A.T.i.C.K.a.a.R      health
        {
            stats: [1, 1, 0],
            name: "DraxCracker",
            damage: 1.3,
            ammo: 2,
            get knockBack() { return Math.random() * 50 },
            fireRate: 0.3,
            collision: "bulletDrill",
            get drill() { return getStats(this.stats) / 5 },
            get bulletsPerShot() { return Math.floor(getStats(this.stats) / 3) },
            offSet: 0.1,
            shake: 10,
            energyAdd: 100,
        },// 4 DraxCracker              arson / sneak
        {
            stats: [0, 1, 0],
            name: "The Luxem",
            fireRate: 0.5,
            speed: 1,
            knockBack: 10,
            shake: 1,
            damage: 1,
            energyAdd: 500,
            ammoDropRate: 200,
            energy: 2000,
            bulletFunction(bullet, i) {
                if (bullet?.time == undefined) {
                    bullet.time = 0
                }

                if (bullet?.inception == undefined) {
                    bullet.inception = getStats(gunValues[bullet.type].stats)
                    bullet.dmg = bullet.inception / 2
                }
                bullet.time += progress / 1000

                let x = Math.min(progress, 10)
                col = addPos(bullet.velX * x, bullet.velY * x, bullet);

                let type = null;
                if (col != null) type = col.collision
                let vels = [{ x: -bullet.velY, y: bullet.velX }, { x: bullet.velY, y: -bullet.velX },]
                if (((bullet.time > 1 / bullet.inception) || (type == "wall")) && obj.bullets.length < 250 && bullet.inception > 1) {
                    bullet.inception--
                    bullet.time = 0
                    gunValues[bullet.type].energy--
                    for (j = 0; j < vels.length; j++) {
                        hot1 = createBullet(gunValues[bullet.type], 0, { x: 0, y: 0 }, bullet.type)
                        hot1.x = bullet.x
                        hot1.y = bullet.y
                        hot1.velX = vels[j].x
                        hot1.velY = vels[j].y
                        hot1.inception = bullet.inception
                        hot1.dmg = bullet.dmg / 1.5
                    }
                }
                if (bullet.x > (loc[0].length * 50) + 50 || bullet.x < -50 || bullet.y > (loc.length * 50) + 50 || bullet.y < - 50 || (type == "wall" || type == "lock")) {
                    obj.bullets.splice(i, 1);
                }
            }
        },// 5 The luxem                arson
        {
            name: "Full Body Blender",
            stats: [0, 1, 1],
            get knockBack() { return Math.random() * 10 },
            get fireRate() { return 0.7 / getStats(this.stats) },
            collision: "bulletBouncy",
            speed: 1.7,
            size: 20,
            get bounce() { return getStats(this.stats) },
            fireFunction(gunNumber, units, rot) {
                hot = defaultFireFunction(gunNumber, units, rot)
                hot.onCollision = bouncyBulletCollision
            },
            shake: 2.7,
            energyAdd: 300,
            energy: 500,
            ammoDropRate: 200,
        },// 6 full body blender        arson / health
        {
            stats: [1, 0, 1],
            name: "DraxDroner",
            damage: 1.4,
            get knockBack() { return Math.random() * 10 },
            get fireRate() { return Math.random() * (1.6 / getStats(this.stats)) },
            collision: "bulletDrill",
            speed: 1.8,
            get drill() { return getStats(this.stats) / 5 },
            shake: 6,
            energyAdd: 150,
            ammoDropRate: 100,
        },// 7 DraxDroner               sneak / health
        {
            stats: [0, 0, 1],
            name: "SandStorm",
            get damage() { return getStats(this.stats) / 1.5 },
            get knockBack() { return Math.random() * 20 },
            get fireRate() {
                this.shotOn++
                if (this.shotOn == 3) {
                    this.shotOn = 0;
                    return 0.15;
                }
                return 0.03
            },
            shotOn: 0,
            speed: 2.5,
            shake: 4,
            energyAdd: 400,
        },// 8 sandStorm                health
        {
            color: 'red',
            name: "Doom Cannon",
            get ammo() { return progress * 35 },
            damage: 10,
            fireRate: 0,
            knockBack: 0.1,
            shake: 4,
            recoil: 0.5,
            fireFunction(type, units, rot) { lazerFire(this, units) },
            barrelLength: 55,
            energy: 1000000,
            energyAdd: 100000,
            ammoDropRate: 150000,
        },// 9 Doom Cannon              make stats
        {
            color: '#e88a36',
            stats: [0, 1, 0],
            name: "The JoyRide",
            ammoDropRate: 500,
            energy: 1000,
            damage: 0.7,
            get knockBack() { return Math.random() * 20 },
            fireRate: 0.03,
            size: 8,
            shake: 2,
            get recoil() { return 1.5 * getStats(this.stats) },
        },// 10 The JoyRide             arson
        {
            stats: [1, 0, 0],
            name: "Two Shot Johnson",
            get damage() { return getStats(this.stats) / 3 },
            get knockBack() { return Math.random() * 40 },
            fireRate: 0.25,
            shake: 4,
            fireFunction(gunNumber, units, rot) {
                type = gunValues[gunNumber]

                createBullet(type, rot, units, gunNumber)
                createBullet(type, Math.atan2(inputVector.yPrev, inputVector.xPrev), { x: inputVector.xPrev, y: inputVector.yPrev }, gunNumber)

                shootTimer = type.fireRate;
                type.energy -= type.ammo;
                addPos(0, -inputVector.yPrev * type.recoil * 2, player);
                addPos(-inputVector.xPrev * type.recoil * 2, 0, player);
                addPos(0, -units.y * type.recoil, player);
                addPos(-units.x * type.recoil, 0, player);
            },
            render(rot) {
                drawGun(rot)
                rot = Math.atan2(inputVector.yPrev, inputVector.xPrev);
                drawGun(rot)
            },
            energyAdd: 75,
            ammo: 2,
        },// 11 Two Shot Johnson        sneak
        {
            color: 'red',
            stats: [1, 0, 0],
            name: "Lazer Focus",
            damage: 1.5,
            get knockBack() { return Math.random() * 50 },
            fireRate: 0.5,
            get pierce() { return getStats(this.stats) },
            shake: 7,
            energyAdd: 25,
            render(rot, units) {
                drawGun(rot)
                let endPoint = { x: 0, y: 0 };
                let done = false;
                for (i = 0; i < 200; i++) {
                    if (!done) {
                        if (
                            loc[clamp(Math.floor(((units.y * 4 * i) + player.y) / 50), 0, loc.length - 1)][clamp(Math.floor(((units.x * 4 * i) + player.x) / 50), 0, loc[0].length - 1)]
                        ) {
                            done = true;
                            endPoint = { x: (units.x * 4 * i) + player.x, y: (units.y * 4 * i) + player.y }
                        }
                        for (ii = 0; ii < obj.enemies.length; ii++) {
                            if (simpleCheckCol({ x: (units.x * 4 * i) + player.x, y: (units.y * 4 * i) + player.y }, obj.enemies[ii], 10)) {
                                obj.enemies[ii].blinded = 0.5;
                            }
                        }
                    }

                }
                if (endPoint.x == 0) {
                    endPoint = { x: (units.x * 4 * 200) + player.x, y: (units.y * 4 * 200) + player.y }
                }

                objects.strokeStyle = "red"
                objects.lineWidth = 1
                objects.beginPath()
                objects.moveTo(player.x + cam.x + (units.x * 55), player.y + cam.y + (units.y * 55));
                objects.lineTo(endPoint.x + cam.x, endPoint.y + cam.y);
                objects.stroke();
                objects.strokeStyle = "#ffffff"
                objects.lineWidth = 2

                lights.globalCompositeOperation = "destination-out"
                lights.lineWidth = 20
                lights.beginPath()
                lights.moveTo(player.x + cam.x, player.y + cam.y);
                lights.lineTo(endPoint.x + cam.x, endPoint.y + cam.y);
                lights.stroke();
            },
        },// 12 Lazer Focus             sneak
        {
            color: '#c4f129',
            name: "Gauss Gun",
            stats: [0, 0, 1],
            get ammo() { return progress / 150 },
            get damage() { return 10 },
            get fireRate() {
                this.shotOn += progress / 1000
                if (this.shotOn > 0.1) {
                    this.shotOn = 0;
                    return 0.6;
                }
                return 0
            },
            knockBack: 0.5,
            shotOn: 0,
            shake: 4,
            recoil: 2,
            fireFunction(type, units, rot) { lazerFire(this, units) },
            barrelLength: 100,
            energyAdd: 100,
        },// 13 Gauss Gun               health
        {
            name: "Four Shot Susan",
            get damage() { return getStats(this.stats) / 3 },
            get knockBack() { return Math.random() * 40 },
            fireRate: 0.25,
            shake: 4,
            fireFunction(gunNumber, units, rot) {
                type = gunValues[gunNumber]

                createBullet(type, rot, units, gunNumber)
                createBullet(type, rot + Math.PI, negVector(units), gunNumber)
                createBullet(type, Math.atan2(inputVector.yPrev, inputVector.xPrev), { x: inputVector.xPrev, y: inputVector.xPrev }, gunNumber)
                createBullet(type, Math.atan2(-inputVector.yPrev, -inputVector.xPrev), { x: -inputVector.xPrev, y: -inputVector.xPrev }, gunNumber)
                shootTimer = type.fireRate;
                type.energy -= type.ammo;
            },
            render(rot) {
                drawGun(rot)
                rot = Math.atan2(inputVector.yPrev, inputVector.xPrev);
                drawGun(rot)
            },
            ammo: 4,
            energyAdd: 230,
        },// 14 Four Shot Susan         replace with something else
        {
            stats: [0, 1, 0],
            name: "The Hindenburg",
            description: "What time is it? Zeppelin!",
            ammo: 1,
            damage: 10,
            fireRate: 1,
            pierce: 1000,
            speed: 0.4,
            shake: 1,
            energy: 40,
            ammoDropRate: 5,
            energyAdd: 15,
            fireFunction(gunNumber, units, rot) {
                hot = defaultFireFunction(gunNumber, units, rot)
                hot.onCollision = function (col) {
                    if (col == t || col.collision == "enemy") {
                        hindenBulletDie(this, obj.bullets.indexOf(this))
                    }
                }
            },
            bulletFunction(b, i) {
                minDist = 40000
                for (j = 0; j < obj.enemies.length; j++) {
                    dist = distanceSquared(b, obj.enemies[j])
                    if (dist < minDist) {
                        if (raycast({ x: b.x, y: b.y }, unitVector(obj.enemies[j].x - b.x, obj.enemies[j].y - b.y), [obj.enemies[j]], 1600, false)) {
                            minDist = dist
                            b.target = obj.enemies[j]
                        }
                    }
                }
                if (b.target != undefined) {
                    vel = unitVector(b.target.x - b.x, b.target.y - b.y)
                    b.velX += vel.x / (progress * 17)
                    b.velY += vel.y / (progress * 17)
                }
                let x = Math.min(progress, 10)
                col = addPos(b.velX * x, b.velY * x, b);

                if (b.x > (loc[0].length * 50) + 50 ||
                    b.x < -50 ||
                    b.y > (loc.length * 50) + 50 ||
                    b.y < - 50
                ) {
                    hindenBulletDie(b, i)
                }
                camShake.shakeLevel = 3
                camShake.length = 0.2
            },
        },// 15 The HindenBurg          arson
        {
            stats: [0, 1, 0],
            name: "Minigatler",
            energy: 10000,
            energyAdd: 1000,
            damage: 0.7,
            get knockBack() { return Math.random() * 20 },
            fireRate: 0.0,
            size: 8,
            speed: 2.5,
            shotNumber: 0,
            shake: 2,
            recoil: 1,
            barrelLength: 50,
            humpSize: 5,
            fireFunction(gunNumber, units, rot) {
                this.shotNumber++
                if (this.shotNumber > this.humpSize - 1) this.shotNumber = 0;
                hot = defaultFireFunction(gunNumber, units, rot)
                hot.x = player.x + (units.x * this.barrelLength) + ((-units.y * (this.shotNumber - (this.humpSize / 2))) * 5)
                hot.y = player.y + (units.y * this.barrelLength) + ((units.x * (this.shotNumber - (this.humpSize / 2))) * 5)
            },
        },// 16 Minigatler              arson
        {
            name: "Cupid",
            get knockBack() { return Math.random() * 40 },
            get loveLength() { return getStats(this.stats) },
            shake: 4,
            bulletHitFunction(objArr, i, g) {
                if (checkCol(obj.bullets[g], objArr[i], 0, 0, 5)) {
                    objArr[i].inLove = obj.bullets[g].loveLevel;
                    obj.bullets[g].pierce -= 1;
                    if (objArr[i]?.noKnockBack != true) { addPos(obj.bullets[g].velX * obj.bullets[g].knockBack, obj.bullets[g].velY * obj.bullets[g].knockBack, objArr[i]); }
                    obj.bullets.splice(g, 1);
                }
            },
            fireFunction(gunNumber, units, rot) {
                hot = defaultFireFunction(gunNumber, units, rot)
                hot.loveLevel = gunValues[gunNumber].loveLength
            },
            ammo: 0
        },// 17 Cupid                   replace with something else
        {
            stats: [1, 0, 1],
            name: "PRx480",
            get ammo() { return Math.min(this.time * (progress / 10000), progress / 200) },
            energy: 100,
            energyAdd: 0,
            get damage() { return getStats(this.stats) / 12 },
            fireRate: 0,
            knockBack: 0.1,
            time: 1,
            recoil: 0,
            get shake() { return Math.min(this.time / 100, 10) },
            fireFunction(type, units, rot) {
                prismlightAudio.play()
                this.time += (progress / 1000) * this.time
                this.color = "#E698A7"
                srot = rot + Math.sin(this.time) / (this.time / 3)
                units = { x: Math.cos(srot), y: Math.sin(srot) }
                lazerFire(this, units)
                this.color = "#E6D7AE"
                srot = rot + Math.sin(this.time + (Math.PI / 2)) / (this.time / 3)
                units = { x: Math.cos(srot), y: Math.sin(srot) }
                lazerFire(this, units)
                this.color = "#81E692"
                srot = rot + Math.sin(this.time + (Math.PI)) / (this.time / 3)
                units = { x: Math.cos(srot), y: Math.sin(srot) }
                lazerFire(this, units)
                this.color = "#8C9DE6"
                srot = rot + Math.sin(this.time + (Math.PI * 1.5)) / (this.time / 3)
                units = { x: Math.cos(srot), y: Math.sin(srot) }
                lazerFire(this, units)

            },
            barrelLength: 55,
            ammoDropRate: 0,
            finishFire() {
                prismlightAudio.pause()
                this.time = 1;
                if (this.energy < getStats(this.stats) * 20) {
                    this.energy += (progress / 400) * getStats(this.stats)
                }
            }
        },// 18 PRx480                  sneak / health
        {
            stats: [1, 0, 0],
            name: "Photoemasculator",
            ammoDropRate: 0,
            energy: 5,
            energyAdd: 0,
            localLevel: 5,
            damage: 0.2,
            fireRate: 0.25,
            pierce: Infinity,
            collision: "bullet",
            bounce: 5,
            size: 15,
            speed: 0.5,
            shake: 1,
            recoil: 0,
            bulletFunction(b, i) {
                minDist = 40000
                b.target = undefined
                for (j = 0; j < obj.enemies.length; j++) {
                    dist = distanceSquared(b, obj.enemies[j])
                    if (dist < minDist) {
                        if (raycast(b, unitVector(subtractVector(obj.enemies[j], b)), [obj.enemies[j]], dist, false)) {
                            minDist = dist
                            b.target = obj.enemies[j]
                        }
                    }
                }
                if (b.target != undefined) {
                    if (distanceSquared(b, b.target) < 400) {
                        b.velX = 0
                        b.velY = 0
                    } else {
                        vel = unitVector(b.target.x - b.x, b.target.y - b.y)
                        b.velX += vel.x / (progress * 10)
                        b.velY += vel.y / (progress * 10)

                        b.velXp = vel.x * 0.5
                        b.velYp = vel.y * 0.5
                    }
                } else {
                    b.velX = b.velXp
                    b.velY = b.velYp
                }
                let x = Math.min(progress, 10)
                addPos(b.velX * x, b.velY * x, b);

                if (b.x > (loc[0].length * 50) + 50 || b.x < -50 || b.y > (loc.length * 50) + 50 || b.y < - 50) {
                    obj.bullets.splice(i, 1);
                }
            },
            fireFunction(gunNumber, units, rot) {
                hot = defaultFireFunction(gunNumber, units, rot)
                hot.velXp = hot.velX
                hot.velYp = hot.velY
                hot.target = undefined
                hot.onCollision = function (col) {
                    {
                        if (col == t) {
                            gunValues[this.type].energy++;
                            obj.bullets.splice(obj.bullets.indexOf(this), 1)
                        }

                        if (col.type == "crate" || col.type == "lock") {
                            this.pierce--
                            if (this.pierce >= 0) {
                                obj.bullets.splice(obj.bullets.indexOf(this), 1)
                            }
                        }
                    }
                }
                if (this.localLevel < getStats(this.stats)) {
                    this.localLevel++;
                    this.energy++;
                }
            },
            bulletHitFunction(objArr, i, g) {
                if (checkCol(obj.bullets[g], objArr[i], 0, 0, 2)) {
                    objArr[i].health -= obj.bullets[g].dmg;
                    bioMass += obj.bullets[g].dmg
                    obj.bullets[g].pierce -= progress / 1000;
                    if (objArr[i]?.noKnockBack != true) { addPos(obj.bullets[g].velX * obj.bullets[g].knockBack, obj.bullets[g].velY * obj.bullets[g].knockBack, objArr[i]); }
                    if (obj.bullets[g].pierce < 0) {
                        obj.bullets.splice(g, 1);
                        //gunValues[gunType].energy++;
                    }
                }
            },
            finishFire() {
                if (obj.bullets.length == 0) this.energy = getStats(this.stats)
            },
        },// 19 Photoemasculator        sneak
        {
            stats: [1, 0, 0],
            name: "The ol' Grappler",
            get damage() { return getStats(this.stats) / 3 },
            get knockBack() { return Math.random() * 40 },
            fireRate: 1,
            shake: 4,
            speed: 1.5,
            energyAdd: 0,
            ammoDropRate: 0,
            energy: 1,
            grappling: null,
            gunLoopFunction() {
                if (this.grappling != null) {
                    bulletDist = subtractVector(player, this.grappling)
                    pull = unitVector(bulletDist.x, bulletDist.y)
                    col = addPos(-pull.x * progress, 0, player) || addPos(0, -pull.y * progress, player)

                    if ((Math.abs(bulletDist.x) < 20 && Math.abs(bulletDist.y) < 20) || col?.collision == "wall") {
                        this.grappling.dispatch = "dispatch"
                        this.grappling = null
                        this.energy = 1
                    }
                }
            },
            render(rot, units) {
                drawGun(rot)

                for (i = 0; i < obj.bullets.length; i++) {
                    if (obj.bullets[i].type == inventory.left) {
                        objects.strokeStyle = "#452a1b"
                        objects.lineWidth = 3
                        objects.beginPath();
                        objects.moveTo(player.x + cam.x + (units.x * 45), player.y + cam.y + (units.y * 45));
                        objects.lineTo(obj.bullets[i].x + cam.x, obj.bullets[i].y + cam.y);
                        objects.stroke();
                    }
                }
            },
            bulletFunction(b, i) {
                if (b?.dispatch == "dispatch") {
                    obj.bullets.splice(i, 1);
                    return
                }
                let col = false;
                let x = Math.min(progress, 10)

                col = addPos(b.velX * x, b.velY * x, b);
                let type = null;
                if (col != null) {
                    type = col.collision;
                }
                let type1 = null;

                if (b.x > (loc[0].length * 50) + 50 ||
                    b.x < -50 ||
                    b.y > (loc.length * 50) + 50 ||
                    b.y < - 50 ||
                    (type == "wall")
                ) {
                    this.grappling = b
                }


            },
            bulletHitFunction(objArr, i, g) {
                if (checkCol(obj.bullets[g], objArr[i], 0, 0, 5)) {
                    objArr[i].health -= obj.bullets[g].dmg;
                    bioMass += obj.bullets[g].dmg
                    if (obj.bullets[g].pierce < 1) obj.bullets.splice(g, 1);
                }
            },
        },// 20 The ol' Grappler        sneak
        {
            name: "Snap Dragon",
            stats: [1, 1, 0],
            damage: 2,
            size: 15,
            speed: 0.5,
            shake: 7,
            energyAdd: 75,
            pierce: 100000,
            bulletHitFunction(objArr, i, g) {
                if (checkCol(obj.bullets[g], objArr[i], 0, 0, 5)) {
                    objArr[i].health -= (obj.bullets[g].dmg * progress / 1000);
                    addPos(obj.bullets[g].velX * 30, obj.bullets[g].velY * 30, objArr[i]);
                    obj.bullets[g].velX /= 2
                    obj.bullets[g].velY /= 2
                }
            },
            bulletFunction(b, i) {

                let col = false;
                let x = Math.min(progress, 10)
                col = addPos(
                    b.velX * x,
                    b.velY * x,
                    b
                );
                un = 0.01 / Math.sqrt((b.velX * b.velX) + (b.velY * b.velY))
                b.velX *= 1 + (b.stats / 200) + un
                b.velY *= 1 + (b.stats / 200) + un

                let type = null;
                if (col != null) {
                    type = col.collision;
                }
                if (b.x > (loc[0].length * 50) + 50 ||
                    b.x < -50 ||
                    b.y > (loc.length * 50) + 50 ||
                    b.y < - 50 ||
                    (type == "wall" && b.collision == "bullet")
                ) {
                    obj.bullets.splice(i, 1);
                }
            },
        },// 21 Snap Dragon             sneak / arson
        {
            name: "Thrust or Bust Baby",
            stats: [0, 1, 0],
            damage: 0.5,
            fireRate: 0.05,
            size: 15,
            speed: 0.4,
            shotNumber: 0,
            shake: 7,
            energyAdd: 230,
            ammoDropRate: 100,
            humpSize: 3,
            recoil: 1,
            barrelLength: 80,
            fireFunction(gunNumber, units, rot) {
                this.shotNumber++
                if (this.shotNumber > this.humpSize - 1) this.shotNumber = 0;
                hot = defaultFireFunction(gunNumber, units, rot)
                hot.x = player.x + (units.x * this.barrelLength) + ((-units.y * (this.shotNumber - (this.humpSize / 2))) * 5)
                hot.y = player.y + (units.y * this.barrelLength) + ((units.x * (this.shotNumber - (this.humpSize / 2))) * 5)
            },
            bulletHitFunction(objArr, i, g) {
                if (checkCol(obj.bullets[g], objArr[i], 0, 0, 5)) {
                    objArr[i].health -= (obj.bullets[g].dmg * progress / 1000);
                    addPos(obj.bullets[g].velX * 30, obj.bullets[g].velY * 30, objArr[i]);
                    obj.bullets[g].velX /= 4
                    obj.bullets[g].velY /= 4
                }
            },
            bulletFunction(b, i) {

                let col = false;
                let x = Math.min(progress, 10)
                col = addPos(
                    b.velX * x,
                    b.velY * x,
                    b
                );
                un = 0.01 / Math.sqrt((b.velX * b.velX) + (b.velY * b.velY))
                b.velX *= 1 + (b.stats / 300) + un
                b.velY *= 1 + (b.stats / 300) + un

                let type = null;
                if (col != null) {
                    type = col.collision;
                }
                if (b.x > (loc[0].length * 50) + 50 ||
                    b.x < -50 ||
                    b.y > (loc.length * 50) + 50 ||
                    b.y < - 50 ||
                    (type == "wall" && b.collision == "bullet")
                ) {
                    obj.bullets.splice(i, 1);
                }
            },
        },// 22 Thrust or Bust Baby     arson
        {
            stats: [0, 0, 1],
            name: "Refractal",
            get ammo() { return progress / 300 },
            barrelLength: 70,
            time: 1,
            fireRate: 0,
            knockBack: 0.05,
            shake: 0,
            recoil: 0,
            fireFunction(gunNumber, units, rot) {
                type = gunValues[gunNumber]
                lengthOfLazer = magnitude(aimPoint.x - player.x, aimPoint.y - player.y) / (4 * zoom)
                this.time += progress / 1000
                let endPoint = { x: 0, y: 0 };
                let done = false;
                for (let i = 0; i < lengthOfLazer; i++) {
                    if (!done) {
                        if (
                            loc[clamp(Math.floor(((units.y * 4 * i) + player.y) / 50), 0, loc.length - 1)][clamp(Math.floor(((units.x * 4 * i) + player.x) / 50), 0, loc[0].length - 1)] == true
                        ) {
                            done = true;
                            endPoint = { x: (units.x * 4 * i) + player.x, y: (units.y * 4 * i) + player.y }
                        }

                        for (ii = 0; ii < obj.enemies.length; ii++) {
                            if (simpleCheckCol({ x: (units.x * 4 * i) + player.x, y: (units.y * 4 * i) + player.y }, obj.enemies[ii], 10)) {
                                obj.enemies[ii].health -= 4 * (progress / 1000);
                                addPos(units.x * type.knockBack * progress, units.y * type.knockBack * progress, obj.enemies[ii]);
                            }
                        }
                    }

                }
                if (endPoint.x == 0) {
                    endPoint = { x: (units.x * 4 * lengthOfLazer) + player.x, y: (units.y * 4 * lengthOfLazer) + player.y }
                }
                objects.strokeStyle = type.color
                objects.lineWidth = 5
                objects.beginPath()
                objects.moveTo(player.x + cam.x + (units.x * type.barrelLength), player.y + cam.y + (units.y * type.barrelLength));
                objects.lineTo(cam.x + endPoint.x, cam.y + endPoint.y);
                objects.stroke();
                objects.strokeStyle = "#ffffff"
                objects.lineWidth = 2

                lights.strokeStyle = "red"
                lights.lineWidth = 20
                lights.beginPath()
                lights.moveTo(player.x + cam.x, player.y + cam.y);
                lights.lineTo(cam.x + endPoint.x, cam.y + endPoint.y);
                lights.stroke();

                shootTimer = type.fireRate;
                type.energy -= type.ammo;
                addPos(0, -units.y * type.recoil, player);
                addPos(-units.x * type.recoil, 0, player);
                this.barrelLength = 0
                this.knockBack = -this.knockBack
                for (let f = 0; f < (this.time * getStats(this.stats) * 0.1) + 3; f++) {
                    srot = Math.sin(this.time + f) * Math.PI
                    units = { x: -Math.cos(srot), y: -Math.sin(srot) }
                    lazerColors = [
                        [151, 237, 202],
                        [206, 170, 237],
                        [115, 239, 232]
                    ]
                    this.color =
                        "rgba(" + ((Math.sin(this.time + f) * (lazerColors[f % 3][0] - lazerColors[(f + 1) % 3][0])) + lazerColors[f % 3][0] + lazerColors[(f + 1) % 3][0]) * 0.5
                        + ", " + ((Math.sin(this.time + f) * (lazerColors[f % 3][1] - lazerColors[(f + 1) % 3][1])) + lazerColors[f % 3][1] + lazerColors[(f + 1) % 3][1]) * 0.5
                        + ", " + ((Math.sin(this.time + f) * (lazerColors[f % 3][2] - lazerColors[(f + 1) % 3][2])) + lazerColors[f % 3][2] + lazerColors[(f + 1) % 3][2]) * 0.5
                        + ", " + ((Math.sin((this.time + f) * 4) / 2) + 0.5) + ")"

                    lazerFire(this, units, { x: endPoint.x + (units.x * 10), y: endPoint.y + (units.y * 10) })
                }
                this.knockBack = -this.knockBack

                this.barrelLength = 70
                this.color = "white"
            },
            energy: 1000,
            energyAdd: 300,
            ammoDropRate: 500,
            finishFire() {
                this.time = 1
            }
        },// 23 Refractal               health
        {
            stats: [1, 0, 0],
            name: "Orion",
            ammo: 5,
            get knockBack() { return Math.random() * 30 },
            fireRate: 0.45,
            bounce: 2,
            collision: "bulletBouncy",
            speed: 1.75,
            get offSet() { return 1 / getStats(this.stats) },
            get bulletsPerShot() { return Math.floor(getStats(this.stats)) },
            shake: 6,
            recoil: 12,
            energy: 600,
            energyAdd: 250,
            barrelLength: 70,
            ammoDropRate: 100,
            fireFunction(gunNumber, units, rot) {
                let type = gunValues[gunNumber]
                let hot = null
                for (i = 0; i < type.bulletsPerShot; i++) {
                    bulletOffSet = type.offSet * (i - (type.bulletsPerShot * 0.5) + 0.5)
                    hot = createBullet(type, rot + bulletOffSet, units, gunNumber)
                    hot.onCollision = bouncyBulletCollision
                }
                shootTimer = type.fireRate;
                type.energy -= type.ammo;
                addPos(0, -units.y * type.recoil, player);
                addPos(-units.x * type.recoil, 0, player);
                return hot
            }
        },// 24 Orion                   sneak
        {
            stats: [0, 0, 1],
            name: "BombStick",
            ammo: 3,
            size: 20,
            get knockBack() { return Math.random() * 30 },
            get damage() { return getStats(this.stats) },
            fireRate: 0.35,
            collision: "bullet",
            speed: 1.5,
            offSet: 1,
            bulletsPerShot: 3,
            shake: 6,
            recoil: 12,
            energy: 600,
            energyAdd: 250,
            barrelLength: 50,
            ammoDropRate: 100,
        },// 25 BombStick                   sneak
        {
            stats: [0, 0, 1],
            name: "Super smoker",
            ammo: 3,
            size: 20,
            get knockBack() { return Math.random() * 30 },
            get damage() { return getStats(this.stats) },
            fireRate: 0.35,
            collision: "bullet",
            speed: 1.5,
            shake: 2,
            energy: 600,
            energyAdd: 250,
            barrelLength: 50,
            ammoDropRate: 100,
            bulletFunction(b, i) {
                let col = false;
                let col1 = false;
                let x = Math.min(progress, 10)
                col = addPos(b.velX * x, b.velY * x, b);

                let type = null;
                if (col != null) {
                    type = col.collision;
                }

                if (b.x > (loc[0].length * 50) + 50 ||
                    b.x < -50 ||
                    b.y > (loc.length * 50) + 50 ||
                    b.y < - 50 ||
                    (type == "wall" && b.collision == "bullet")
                ) {
                    obj.bullets.splice(i, 1);
                } else
                    if (b.collision == "bulletBouncy") {

                        if (b.bounce < 1) {
                            obj.bullets.splice(i, 1);
                        } else {
                            if (type == "wall") {
                                b.bounce--;
                                b.velX = -b.velX;
                            }

                            if (type1 == "wall") {
                                b.bounce--;
                                b.velY = -b.velY;
                            }
                        }
                    }
                if (b.time == undefined) {
                    b.time = 0
                }

                b.time += progress / 1000
                if (b.time > 0.14) {
                    makeSplashObj(b, "lava")
                    obj.bullets.splice(i, 1)
                }
            },
        },// 26 Super smoker                sneak
        {
            stats: [0, 0, 1],
            name: "Biohazard",
            ammo: 3,
            size: 20,
            get knockBack() { return Math.random() * 30 },
            get damage() { return getStats(this.stats) },
            fireRate: 0.35,
            collision: "bullet",
            speed: 1.5,
            shake: 2,
            energy: 600,
            energyAdd: 250,
            barrelLength: 50,
            ammoDropRate: 100,
            bulletFunction(b, i) {
                let col = false;
                let col1 = false;
                let x = Math.min(progress, 10)
                col = addPos(b.velX * x, b.velY * x, b);

                let type = null;
                if (col != null) {
                    type = col.collision;
                }

                if (b.x > (loc[0].length * 50) + 50 ||
                    b.x < -50 ||
                    b.y > (loc.length * 50) + 50 ||
                    b.y < - 50 ||
                    (type == "wall" && b.collision == "bullet")
                ) {
                    obj.bullets.splice(i, 1);
                } else
                    if (b.collision == "bulletBouncy") {

                        if (b.bounce < 1) {
                            obj.bullets.splice(i, 1);
                        } else {
                            if (type == "wall") {
                                b.bounce--;
                                b.velX = -b.velX;
                            }

                            if (type1 == "wall") {
                                b.bounce--;
                                b.velY = -b.velY;
                            }
                        }
                    }
                if (b.time == undefined) {
                    b.time = 0
                }

                b.time += progress / 1000
                if (b.time > 0.14) {
                    makeSplashObj(b, "poison")
                    obj.bullets.splice(i, 1)
                }
            },
        },// 26 Biohazard                sneak
        {
            name: "Bayonet",
            length: 130,
            damage: 5,
            knockBack: 80,
            swingSpeed: 0.4,
            swingWidth: 1.5,
            animPos: -2,
            animSpeed: 2,
            fireFunction(gunNumber, units, rot) {
                defaultFireFunction(gunNumber, units, rot)
                for (i = 0; i < obj.enemies.length; i++) {
                    if (distance(player, obj.enemies[i]) < this.length) {
                        units = subtractVector(obj.enemies[i], player)
                        units = unitVector(units.x, units.y)
                        rotOfEn = Math.atan2(units.y, units.x)
                        if (Math.abs(rotOfEn - rot) < this.swingWidth || Math.abs(rotOfEn - rot + (Math.PI * 2)) < this.swingWidth || Math.abs(rotOfEn - rot - (Math.PI * 2)) < this.swingWidth) {
                            obj.enemies[i].health -= this.damage
                            addPos(units.x * this.knockBack, units.y * this.knockBack, obj.enemies[i])
                        }
                    }
                }
                shootTimer = this.swingSpeed
                this.animPos = this.swingWidth
            },
            render(rot) {
                if (this.animPos > -this.swingWidth) {
                    drawGun(rot + this.animPos)
                    this.animPos -= ((progress * this.swingWidth * 2 * this.animSpeed) / this.swingSpeed) / 1000
                } else {
                    drawGun(rot)
                }
            }
        },// 27 Bayonet
        {
            stats: [0, 0, 1],
            name: "Splashpad",
            ammo: 3,
            size: 20,
            get knockBack() { return Math.random() * 30 },
            get damage() { return getStats(this.stats) },
            fireFunction(gunNumber, units, rot) {
                hot = defaultFireFunction(gunNumber, units, rot)
                hot.time = 0
            },
            fireRate: 0.35,
            collision: "bullet",
            speed: 1,
            shake: 6,
            recoil: 12,
            energy: 600,
            energyAdd: 250,
            barrelLength: 50,
            ammoDropRate: 100,
            bulletFunction(b, i) {
                let x = Math.min(progress, 10)
                addPos(b.velX * x, b.velY * x, b);

                if (b.x > (loc[0].length * 50) + 50 || b.x < -50 || b.y > (loc.length * 50) + 50 || b.y < - 50) {
                    obj.bullets.splice(i, 1);
                }

                b.time += progress / 1000
                if (b.time > 0.1 && b.split == undefined) {
                    let vels = [{ x: -b.velY, y: b.velX }, { x: b.velY, y: -b.velX },]
                    for (j = 0; j < vels.length; j++) {
                        hot1 = createBullet(gunValues[b.type], 0, { x: 0, y: 0 }, b.type)
                        hot1.x = b.x
                        hot1.y = b.y
                        hot1.velX = vels[j].x
                        hot1.velY = vels[j].y
                        hot1.dmg = b.dmg / 1.5
                    }
                    b.split = "first"
                    b.velX *= 1.5
                    b.velY *= 1.5
                }

                if (b.time > 0.2 && b.split == "first") {
                    let vels = [{ x: -b.velY, y: b.velX }, { x: b.velY, y: -b.velX },]
                    let type = gunValues[b.type]
                    for (j = 0; j < vels.length; j++) {

                        let hot = null
                        units = unitVector(b.velX, b.velY)
                        rot = Math.atan2(units.y, units.x)
                        for (i = 0; i < 3; i++) {
                            bulletOffSet = 0.2 * (i - (3 * 0.5) + 0.5)
                            hot = createBullet(type, rot + bulletOffSet, units, b.type)
                            hot.split = "second"
                            hot.x = b.x
                            hot.y = b.y
                        }
                    }
                    type.bulletsPerShot = 1
                    b.split = "second"
                    obj.bullets.splice(i, 1)
                }
            }
        },// 28 Splashpad                   sneak
    ]

    let swordValues = [
        {
            name: "Broken Hero Sword",
            length: 100,
            damage: 5,
            knockBack: 80,
            swingSpeed: 0.4,
            swingWidth: 2,
            animPos: -2,
            animSpeed: 2,
            swingFunction(rot) {
                for (i = 0; i < obj.enemies.length; i++) {
                    if (distance(player, obj.enemies[i]) < this.length) {
                        units = subtractVector(obj.enemies[i], player)
                        units = unitVector(units.x, units.y)
                        rotOfEn = Math.atan2(units.y, units.x)
                        if (Math.abs(rotOfEn - rot) < this.swingWidth || Math.abs(rotOfEn - rot + (Math.PI * 2)) < this.swingWidth || Math.abs(rotOfEn - rot - (Math.PI * 2)) < this.swingWidth) {
                            obj.enemies[i].health -= this.damage
                            addPos(units.x * this.knockBack, units.y * this.knockBack, obj.enemies[i])
                        }
                    }
                }
                shootTimer = this.swingSpeed
                this.animPos = this.swingWidth
            },
            render(rot) {
                if (this.animPos > -this.swingWidth) {
                    drawSword(rot + this.animPos)
                    this.animPos -= ((progress * this.swingWidth * 2 * this.animSpeed) / this.swingSpeed) / 1000
                }
            }
        }
    ]

    function makeSplashObj(b, type) {

        obj.objects.push({
            x: b.x,
            y: b.y,
            width: 100,
            height: 100,
            solid: false,
            splashType: type,
            time: 0,
            type: "lavaSplash",
            update(i) {
                this.time += progress / 1000
                if (this.time > 3) {
                    obj.objects.splice(i, 1)
                }

            },
            draw(i) {
                sheetX = 0
                if (this.splashType == "poison") {
                    sheetX = 32
                }
                objects.drawImage(entitySprites, sheetX, 160, 32, 32, this.x + cam.x - (this.width / 2), this.y + cam.y - (this.height / 2), this.width, this.height)
                light(this.x, this.y, 100, 1)
            },
            onCollision(col) {
                if (col.collision == "enemy") {
                    col.health -= progress / 250
                }
            },
        })
    }

    function regularBulletColFunction(col) {
        if (col == t) {
            if (col == t || col.collision == "enemy") {
                obj.bullets.splice(obj.bullets.indexOf(this), 1)
            }
        }
    }

    function bouncyBulletCollision(col, hits) {
        if (col == t) {
            console.log(hits)
            if ((hits[0] && hits[1] && this.velX > 0) || (hits[2] && hits[3] && this.velX < 0)) {
                this.velX = -this.velX
            }

            if ((hits[0] && hits[2] && this.velY > 0) || (hits[1] && hits[3] && this.velY < 0)) {
                this.velY = -this.velY
            }
            this.bounce--
            if (this.bounce < 0) {
                obj.bullets.splice(obj.bullets.indexOf(this), 1)
            }
        }

        if (col.collision == "enemy") {
            this.pierce--
            if (this.pierce <= 0) {
                obj.bullets.splice(obj.bullets.indexOf(this), 1)
            }
        }

        if (col.type == "crate" || col.type == "lock") {
            this.pierce--
            if (this.pierce >= 0) {
                obj.bullets.splice(obj.bullets.indexOf(this), 1)
            }
        }
    }

    /*4's name stands for: Magnetic Acceleration Apparatus That is Commonly Known as a Railgun */
    gunStatNames = ["stats", "name", "ammo", "damage", "knockBack", "fireRate", "collision", "size", "speed", "offSet", "bulletsPerShot", "pierce", "drill", "shake", "recoil", "fireFunction", "render", "bulletFunction", "bulletHitFunction", "finishFire", "gunLoopFunction", "energy", "energyAdd", "ammoDropRate", "barrelLength"]
    gunStatNormal = [
            /*stats*/[0.35, 0.3, 0.35], /*Name*/"Gun", /*ammo*/1, /*damage*/3, /*knockBack*/0, /*fireRate*/0.2, /*collision*/"bullet", /*size*/10, /*speed*/2, /*offset*/0, /*bulletsPerShot*/1, /*pierce*/1, /*drill*/0, /*shake*/5, /*recoil*/5,
            /*Fire Function*/ function (gunNumber, units, rot) { defaultFireFunction(gunNumber, units, rot) },
            /*Render*/ function (rot) { drawGun(rot) },
            /*Bullet Function*/ function (b) {
            let col = false;
            let col1 = false;
            let x = Math.min(progress, 10)
            if (b.collision == "bullet" || b.collision == "bulletDrill") {
                col = addPos(
                    b.velX * x,
                    b.velY * x,
                    b
                );
            } else if (b.collision == "bulletBouncy") {
                col = addPos(
                    b.velX * x,
                    0,
                    b
                );
                col1 = addPos(
                    0,
                    b.velY * x,
                    b
                );
            }

            let type = null;
            if (col != null) {
                type = col.collision;
            }
            let type1 = null;
            if (col1 != null) {
                type1 = col1.collision;
            }

            if (b.x > (loc[0].length * 50) + 50 ||
                b.x < -50 ||
                b.y > (loc.length * 50) + 50 ||
                b.y < - 50 ||
                (type == "wall" && b.collision == "bullet")
            ) {
                obj.bullets.splice(i, 1);
            } else
                if (b.collision == "bulletBouncy") {

                    if (b.bounce < 1) {
                        obj.bullets.splice(i, 1);
                    } else {
                        if (type == "wall") {
                            b.bounce--;
                            b.velX = -b.velX;
                        }

                        if (type1 == "wall") {
                            b.bounce--;
                            b.velY = -b.velY;
                        }
                    }
                } else if (b.collision == "bulletDrill") {
                    if (type == "wall") {
                        b.drill -= progress / 1000;
                        if (b.drill < 0) {
                            obj.bullets.splice(i, 1);
                        }
                    }
                }
        },
            /*Bullet Hit Function*/ function (objArr, i, g) {
            if (checkCol(obj.bullets[g], objArr[i], 0, 0, 5)) {
                objArr[i].health -= obj.bullets[g].dmg;
                bioMass += obj.bullets[g].dmg
                obj.bullets[g].pierce -= 1;
                if (objArr[i]?.noKnockBack != true) { addPos(obj.bullets[g].velX * obj.bullets[g].knockBack, obj.bullets[g].velY * obj.bullets[g].knockBack, objArr[i]); }
                if (obj.bullets[g].pierce < 1) obj.bullets.splice(g, 1);
            }
        },
            /*Finish Fire*/ function () { },
            /*Gun Loop Function*/ function () { },
            /*energy*/120, /*energyAdd*/50, /*ammoDropRate*/30, /*BarrelLength*/30,
    ]
    for (i = 0; i < gunValues.length; i++) {
        for (ii = 0; ii < gunStatNames.length; ii++) {
            if (gunValues[i][gunStatNames[ii]] == undefined) {
                gunValues[i][gunStatNames[ii]] = gunStatNormal[ii];
            }
        }
    }
    /*gunValues.indexOf(gunValues.find(element => element.name.toLowerCase() == "splashpad"))*/
    let inventory = { left: { type: "gun", value: Math.floor(Math.random() * gunValues.length) }, right: { type: "gun", value: Math.floor(Math.random() * gunValues.length) }, backup: { type: "none", value: 0 } }

    function getStats(statsOf) { return Math.pow(1.2, Math.max(((lStats["sneak"]) * statsOf[0]), ((lStats["arson"]) * statsOf[1]), ((lStats["health"]) * statsOf[2]))) + 5 }

    function defaultBulletFunction(b, i) {
        let col = false;
        let col1 = false;
        let x = Math.min(progress, 10)
        col = addPos(b.velX * x, b.velY * x, b);

        let type = null;
        if (col != null) {
            type = col.collision;
        }

        if (b.x > (loc[0].length * 50) + 50 ||
            b.x < -50 ||
            b.y > (loc.length * 50) + 50 ||
            b.y < - 50 ||
            (type == "wall" && b.collision == "bullet")
        ) {
            obj.bullets.splice(i, 1);
        } else
            if (b.collision == "bulletBouncy") {

                if (b.bounce < 1) {
                    obj.bullets.splice(i, 1);
                } else {
                    if (type == "wall") {
                        b.bounce--;
                        b.velX = -b.velX;
                    }

                    if (type1 == "wall") {
                        b.bounce--;
                        b.velY = -b.velY;
                    }
                }
            } else if (b.collision == "bulletDrill") {
                if (type == "wall") {
                    b.drill -= progress / 1000;
                    if (b.drill < 0) {
                        obj.bullets.splice(i, 1);
                    }
                }
            }
    }

    function hindenBulletDie(b, i) {
        obj.objects.push({
            time: 0,
            x: b.x,
            y: b.y,
            anim: {
                source: entitySprites,
                animations: {
                    cell: { current: 0, speed: 80, frames: 5, width: 64, height: 64, sheetX: 0, sheetY: 96 }
                },
                animOn: "cell"
            },
            update(i) {
                this.time += progress / 1000
                if (this.time > 0.320) {
                    obj.objects.splice(i, 1)
                }
            },
            draw() {
                animate(objects, this.x + cam.x - 100, this.y + cam.y - 100, this.anim, 200, 200, 1, 1)
                light(this.x, this.y, 200, 1)
            }
        })
        obj.bullets.splice(i, 1);
        for (j = 0; j < obj.enemies.length; j++) {
            if (distance(b, obj.enemies[j]) < 100) {
                obj.enemies[j].health -= b.dmg
            }
        }
    }

    function createBullet(type, rot, units, gunNumber) {
        let bulletCreated = {
            stats: getStats(type.stats), x: player.x + (units.x * type.barrelLength), y: player.y + (units.y * type.barrelLength), width: type.size, height: type.size, velX: Math.cos(rot) * type.speed, velY: Math.sin(rot) * type.speed, collision: "bullet", dmg: type.damage, pierce: type.pierce, knockBack: type.knockBack, drill: type.drill, bounce: type.bounce, type: gunNumber, onCollision(col, tiles) {
                if (col == t) {
                    obj.bullets.splice(obj.bullets.indexOf(this), 1)
                }

                if (col.collision == "enemy") {
                    this.pierce--
                    if (this.pierce <= 0) {
                        obj.bullets.splice(obj.bullets.indexOf(this), 1)
                    }
                }

                if (col.type == "crate" || col.type == "lock") {
                    this.pierce--
                    if (this.pierce >= 0) {
                        obj.bullets.splice(obj.bullets.indexOf(this), 1)
                    }
                }
            },
        }
        obj.bullets.push(bulletCreated);
        return bulletCreated
    }

    function drawGun(rot) {
        objects.save();
        objects.translate(player.x + cam.x, player.y + cam.y);
        objects.rotate(rot);
        objects.drawImage(gunSprites, (inventory.left.value % 8) * 32, Math.floor(inventory.left.value / 8) * 16, 32, 16, 10, -26, 96, 48);
        objects.restore();
    }

    function drawSword(rot) {
        objects.save();
        objects.translate(player.x + cam.x, player.y + cam.y);
        objects.rotate(rot);
        objects.drawImage(gunSprites, (inventory.left.value % 8) * 32 + 512, Math.floor(inventory.left.value / 8) * 16, 32, 16, 10, -26, 96, 48);
        objects.restore();
    }

    function defaultFireFunction(gunNumber, units, rot) {
        let type = gunValues[gunNumber]
        let hot = null
        for (i = 0; i < type.bulletsPerShot; i++) {
            bulletOffSet = type.offSet * (i - (type.bulletsPerShot * 0.5) + 0.5)
            hot = createBullet(type, rot + bulletOffSet, units, gunNumber)
        }
        shootTimer = type.fireRate;
        type.energy -= type.ammo;
        addPos(0, -units.y * type.recoil, player);
        addPos(-units.x * type.recoil, 0, player);
        return hot
    }

    function lazerFire(type, units, start) {
        let endPoint = { x: 0, y: 0 };
        if (start == undefined) {
            start = player
        }
        let done = false;
        for (let i = 0; i < 200; i++) {
            if (!done) {
                if (
                    loc[clamp(Math.floor(((units.y * 4 * i) + start.y) / 50), 0, loc.length - 1)][clamp(Math.floor(((units.x * 4 * i) + start.x) / 50), 0, loc[0].length - 1)] == true
                ) {
                    done = true;
                    endPoint = { x: (units.x * 4 * i) + start.x, y: (units.y * 4 * i) + start.y }
                }

                for (ii = 0; ii < obj.enemies.length; ii++) {
                    if (simpleCheckCol({ x: (units.x * 4 * i) + start.x, y: (units.y * 4 * i) + start.y }, obj.enemies[ii], 10)) {
                        enemyTakeDamage.bind(obj.enemies[ii])(type.damage, false)
                        enemyTakeKnockBack.bind(obj.enemies[ii])(units, type.knockBack)
                    }
                }
            }

        }
        if (endPoint.x == 0) {
            endPoint = { x: (units.x * 4 * 200) + start.x, y: (units.y * 4 * 200) + start.y }
        }
        objects.strokeStyle = type.color
        objects.lineWidth = 5
        objects.beginPath()
        objects.moveTo(start.x + cam.x + (units.x * type.barrelLength), start.y + cam.y + (units.y * type.barrelLength));
        objects.lineTo(cam.x + endPoint.x, cam.y + endPoint.y);
        objects.stroke();
        objects.strokeStyle = "#ffffff"
        objects.lineWidth = 2

        lights.strokeStyle = "red"
        lights.lineWidth = 20
        lights.beginPath()
        lights.moveTo(start.x + cam.x, start.y + cam.y);
        lights.lineTo(cam.x + endPoint.x, cam.y + endPoint.y);
        lights.stroke();


        shootTimer = type.fireRate;
        type.energy -= type.ammo;
        addPos(0, -units.y * type.recoil, start);
        addPos(-units.x * type.recoil, 0, start);
    }

    frameOn = 0 // the frame that the game is on

    // Sprite sheets
    let entitySprites = imageSRC("enemySheet.png")
    let gunSprites = imageSRC("gunSprites.png");

    function defaultEnemyOnCollision(col, tiles) {
        if (col.collision == "bullet" && col.type != "enemyBullet") {
            this.health -= col.dmg;
            enemyTakeDamage(this, col.dmg, col?.doIFrames ?? true)
            enemyTakeKnockBack({ x: col.velX, y: col.velY }, col.knockBack)
            col.pierce -= 1;
            this.iFrames = 0
        }
    }

    function enemyTakeDamage(damage, causeIFrames) {
        if (this.iFrames != undefined) {
            if (this.iFrames < 0) {
                this.health -= damage
                bioMass += damage
                if (causeIFrames != false) {
                    this.iframes = -this?.iframeDuration || -0.2
                }
            }
        }
    }

    function enemyTakeKnockBack(knockBackUnits, knockBackMagnitude) {
        if (this?.knockBackTakenOn != frameOn) {
            console.log("before", this.knockBackTakenOn, frameOn)
            this.knockBackTakenOn = frameOn
            console.log("after", this.knockBackTakenOn, frameOn)
            addPos(knockBackUnits.x * knockBackMagnitude * progress, knockBackUnits.y * knockBackMagnitude * progress, this)
        }
    }

    function enemySpawnFunction(spawnType, spawnPos) {
        type = enemyValues[spawnType]
        newEnemy = {
            iFrames: 0,
            health: type.health,
            x: (spawnPos.x * 50) + 25,
            y: (spawnPos.y * 50) + 25,
            speed: type.speed,
            damage: type.damage,
            width: type.size.x, height: type.size.y,
            colWidth: type.colSize.x, colHeight: type.colSize.y,
            collision: "enemy",
            moved: { x: 0, y: 0 }, target: { x: 0, y: 0 }, blinded: 0,
            type: spawnType,
            idleTarget: { x: 0, y: 0 },
            onCollision: type.onCollision,
        }

        obj.enemies.push(newEnemy);
        return newEnemy
    }

    function enemyBlindedFunction(e) {
        if (e.blinded < 0) {
            e.target.x = player.x
            e.target.y = player.y
        } else {
            e.blinded -= progress / 1000;
        }
    }

    function enemyApproachTarget(e, speed) {
        units = unitVector(e.target.x - e.x, e.target.y - e.y);
        addPos(0, units.y * (speed ?? e.speed) * progress, e);
        addPos(units.x * (speed ?? e.speed) * progress, 0, e);
    }

    function enemyPlayerInView(e) {
        return raycast({ x: e.x, y: e.y }, unitVector(player.x - e.x, player.y - e.y), [player], 1600, false)
    }

    function enemyIdleTarget(e) {
        if (Math.random() > 0.99 && e.idleTarget.x == 0 && e.idleTarget.y == 0) {
            e.idleTarget = { x: e.x - 60 + (Math.random() * 120), y: e.y - 60 + (Math.random() * 120) }
        }
        if (e.idleTarget.x != 0 && e.idleTarget.y != 0) {
            if (simpleCheckCol(e, e.idleTarget, 10) == false) {
                units = unitVector(e.idleTarget.x - e.x, e.idleTarget.y - e.y);
                col = addPos(0, units.y * e.speed * progress, e) || addPos(units.x * e.speed * progress, 0, e);
                if (col?.collision != undefined) {
                    e.idleTarget.x = 0
                    e.idleTarget.y = 0
                }
                e.animations.animOn = "run"
            } else {
                e.idleTarget.x = 0
                e.idleTarget.y = 0
            }
        }
    }

    let enemyValues = {
        rakamakra: {
            size: { x: 40, y: 40 },
            colSize: { x: 20, y: 20 },
            health: 7,
            speed: 0.18,
            damage: 25,
            onCollision: defaultEnemyOnCollision,
            spawnFunction(spawnType, spawnPos) {
                newEnemy = enemySpawnFunction(spawnType, spawnPos)
                newEnemy.animations = {
                    source: entitySprites,
                    animations: {
                        stand: { current: 0, frames: 3, width: 24, height: 14, speed: 200, sheetX: 0, sheetY: 0 },
                        run: { current: 0, frames: 5, width: 24, height: 14, speed: 90, sheetX: 0, sheetY: 14 },
                    },
                    animOn: "stand"
                }
            },
            loop(e, i) {
                e.iFrames -= progress / 1000
                enemyBlindedFunction(e)

                if (enemyPlayerInView(e)) {
                    enemyApproachTarget(e)
                    e.animations.animOn = "run"
                } else {
                    enemyIdleTarget(e)
                    e.animations.animOn = "stand"
                    if (simpleCheckCol(e, e.idleTarget, 10) == false) e.animations.animOn = "run"
                }
            }
        },

        bulletTurtle: {
            speed: 0.09,
            size: { x: 40, y: 40 },
            colSize: { x: 20, y: 20 },
            health: 4,
            damage: 0,
            onCollision: defaultEnemyOnCollision,

            spawnFunction(spawnType, spawnPos) {
                ne = enemySpawnFunction(spawnType, spawnPos)
                ne.dir = 1
                ne.shootTimer = 0
                ne.shootSpeed = 1
                ne.bulletSpeed = 0.3
                ne.animations = {
                    source: entitySprites,
                    animations: {
                        stand: { current: 0, frames: 1, width: 18, height: 14, speed: 200, sheetX: 0, sheetY: 28 },
                        walk: { current: 0, frames: 4, width: 18, height: 14, speed: 120, sheetX: 0, sheetY: 42 },
                    },
                    animOn: "stand"
                }
                ne.crystalAnimations = {
                    source: entitySprites,
                    animations: {
                        idle: { current: 0, frames: 1, width: 18, height: 14, speed: 200, sheetX: 0, sheetY: 56 },
                        shoot: { current: 0, frames: 4, width: 18, height: 14, speed: 60, sheetX: 0, sheetY: 70 },
                    },
                    animOn: "idle"
                }
                ne.crystalAnimTimer = 0
            },

            loop(e, i) {
                enemyBlindedFunction(e)
                e.iFrames -= progress / 1000

                if (raycast({ x: e.x, y: e.y }, unitVector(player.x - e.x, player.y - e.y), [player], 1600, false)) {
                    e.animations.animOn = "walk"
                    units = unitVector(e.target.x - e.x, e.target.y - e.y);

                    if (magnitude(e.target.x - e.x, e.target.y - e.y) > 200) {
                        if (e.dir == 1) {
                            col = addPos(0, -(units.x * e.speed * progress), e) || addPos((units.y * e.speed * progress), 0, e);
                            if (col?.collision == "wall") {
                                e.dir = -e.dir
                            }
                        } else {
                            col = addPos(0, (units.x * e.speed * progress), e) || -addPos((units.y * e.speed * progress), 0, e);
                            if (col?.collision == "wall") {
                                e.dir = -e.dir
                            }
                        }

                    } else {
                        addPos(0, -(units.y * e.speed * progress), e);
                        addPos(-(units.x * e.speed * progress), 0, e);
                    }

                    e.shootTimer += progress / 1000
                    if (e.shootTimer > e.shootSpeed) {
                        e.shootTimer = 0
                        units = unitVector(player.x - e.x, player.y - e.y);
                        let rot = Math.atan2(units.y, units.x)
                        let hot = {
                            x: e.x + (units.x * 20), y: e.y + (units.y * 20),
                            width: 10, height: 10,
                            velX: Math.cos(rot) * e.bulletSpeed, velY: Math.sin(rot) * e.bulletSpeed,
                            collision: "bullet", dmg: 8, pierce: 1, knockBack: 10, drill: 0, bounce: 0,
                            type: "enemyBullet",
                            onCollision(col) {
                                if (col == t || col.collision == "player") {
                                    obj.enemyBullets.splice(obj.enemyBullets.indexOf(this), 1)
                                }
                            }
                        };
                        obj.enemyBullets.push(hot);
                        e.crystalAnimTimer = 240
                    }
                } else {
                    e.animations.animOn = "stand"
                }
            },

            draw(e, i) {
                e.iFrames -= progress / 1000
                if (e.crystalAnimTimer > 0) {
                    e.crystalAnimations.animOn = "shoot"
                    e.crystalAnimTimer -= progress
                } else {
                    e.crystalAnimations.animOn = "idle"
                }

                animate(objects, e.x - (e.width / 2) + cam.x, e.y - (e.height / 2) + cam.y, e.crystalAnimations, e.width, e.height, scale, 1)

                light(e.x, e.y, 50, 1)

            },
        },

        frenziedRacoon: {
            size: { x: 40, y: 40 },
            colSize: { x: 20, y: 20 },
            spawnFunction(spawnType, spawnPos) {
                obj.enemies.push({
                    iFrames: 0,
                    health: 7 * difficulty,
                    x: (spawnPos.x * 50) + 25,
                    y: (spawnPos.y * 50) + 25,
                    speed: 0.3,
                    inLove: 0, loveFor: 0,
                    damage: 25 * difficulty,
                    width: enemyValues[spawnType].size.x, height: enemyValues[spawnType].size.y,
                    colWidth: enemyValues[spawnType].colSize.x, colHeight: enemyValues[spawnType].colSize.y,
                    collision: "enemy",
                    state: "frenzy",
                    jumpTimer: 0,
                    moved: { x: 0, y: 0 }, target: { x: 0, y: 0 }, blinded: 0,
                    type: spawnType,
                    animations: {
                        source: entitySprites,
                        animations: {
                            stand: { current: 0, frames: 3, width: 24, height: 14, speed: 200, sheetX: 0, sheetY: 0 },
                            run: { current: 0, frames: 5, width: 24, height: 14, speed: 90, sheetX: 0, sheetY: 14 },
                        },
                        animOn: "stand"
                    },
                    idleTarget: { x: 0, y: 0 },
                    onCollision: defaultEnemyOnCollision,
                });
            },
            loop(e, i) {
                e.iFrames -= progress / 1000

                enemyBlindedFunction(e)

                if (raycast({ x: e.x, y: e.y }, unitVector(player.x - e.x, player.y - e.y), [player], 1600, false)) {
                    distanceToPlayer = distance(e, player)
                    if (distanceToPlayer < 130 && e.state == "frenzy") {
                        e.state = "aboutToJump"
                    }

                    if (e.state == "frenzy") {
                        enemyApproachTarget(e)
                        e.animations.animOn = "run"
                    }
                    if (e.state == "aboutToJump") {
                        e.jumpTimer += progress / 1000
                    }
                    if (e.state == "jump") {
                        enemyApproachTarget(e, 0.6)
                        e.animations.animOn = "run"
                        e.jumpTimer -= progress / 1000
                        if (e.jumpTimer < 0) {
                            e.state = "jumpCoolDown"
                        }
                    }
                    if (e.jumpTimer > 0.35 && e.state == "aboutToJump") {
                        e.state = "jump"
                    }
                    if (e.state == "jumpCoolDown") {
                        e.jumpTimer += progress / 1000
                        if (e.jumpTimer > 0.85) {
                            e.state = "frenzy"
                        }
                    }
                } else {
                    enemyIdleTarget(e)
                    e.animations.animOn = "stand"
                    if (simpleCheckCol(e, e.idleTarget, 10) == false) e.animations.animOn = "run"
                }
            }
        },

        cloneSlime: {
            size: { x: 35, y: 35 },
            colSize: { x: 20, y: 20 },
            health: 999999999.999,
            speed: 0.1,
            damage: 15,
            onCollision(col, tiles) {
                if (col.collision == "bullet" && col.type != "enemyBullet" && this.iFrames < 0 && obj.enemies.length < 100) {
                    enemyValues.cloneSlime.spawnFunction("cloneSlime", { x: this.x / 50 - 0.5, y: this.y / 50 - 0.5 })
                    this.iFrames = 0.5
                    this.doPoof()
                }
            },
            spawnFunction(spawnType, spawnPos) {
                ne = enemySpawnFunction(spawnType, spawnPos)
                ne.iFrames = 0.5
                ne.animations = {
                    source: entitySprites,
                    animations: {
                        idle: { current: 0, frames: 1, width: 11, height: 12, speed: 200, sheetX: 16, sheetY: 30 },
                        bounce: { current: 0, frames: 5, width: 11, height: 12, speed: 120, sheetX: 16, sheetY: 30 },
                    },
                    animOn: "idle"
                }
                ne.doPoof = function () {
                    obj.objects.push({
                        time: 0,
                        x: this.x,
                        y: this.y,
                        anim: {
                            source: entitySprites,
                            animations: {
                                cell: { current: 0, speed: 80, frames: 4, width: 26, height: 23, sheetX: 80, sheetY: 32 }
                            },
                            animOn: "cell"
                        },
                        update(i) {
                            this.time += progress / 1000
                            if (this.time > 0.320) {
                                obj.objects.splice(i, 1)
                            }
                        },
                        draw() {
                            animate(objects, this.x + cam.x - 40, this.y + cam.y - 40, this.anim, 80, 80, 1, 1)
                        },
                    })
                }
            },

            loop(e, i) {

                e.iFrames -= progress / 1000
                enemyIdleTarget(e)
                if (e.idleTarget.x != 0 && e.idleTarget.y != 0) {
                    e.animations.animOn = "bounce"
                } else {
                    e.animations.animations.bounce.current = 0
                }
                e.animations.animOn = "idle"

                if (e.iFrames < -10) {
                    obj.enemies.splice(i, 1)
                    e.doPoof()
                }
            },
        },
    }

    let rightClickEnabled = false;
    let doScreenShake = true;
    let customMouse = true;
    let goreLevel = 2;

    let gameStarted = false;

    let brightness = 0.5
    let player = {
        width: 20, height: 40, x: 0, y: 0, collision: "player", health: 100, maxHealth: 100,
        onCollision(col, tile) {
            if (!debugMode && rollTimer <= 0 && iFrameTimer <= 0) {
                if (col.collision == "enemy") {

                    player.health -= col.damage;
                    flashLightSize = 170
                    iFrameTimer = iFrames;
                }
                if (col == cr) {
                    iFrameTimer = iFrames;
                    player.health -= 25
                }
                if (col.type == "enemyBullet") {
                    player.health -= col.dmg;
                    flashLightSize = 170
                }
            }
        },
    }
    let obj = { bullets: [], enemies: [], walls: [], tileDebug: [], collects: [], objects: [], splatters: [], UI: [], enemyBullets: [], player: [player] }

    let triggerMap = {
        bullet: { layers: ["enemies", "objects"], solids: ["objects"], tiles: [t], solidTiles: [t] },
        enemy: { layers: ["enemies", "objects", "bullets", "player"], solids: ["objects"], tiles: [t, cr], solidTiles: [t] },
        collects: { layers: ["player"], tiles: [] },
        objects: { layers: ["player", "bullets", "enemies", "collects", "enemyBullets"], tiles: [] },
        enemyBullets: { layers: ["player", "objects"], solids: ["objects"], tiles: [t], solidTiles: [t] },
        player: { layers: ["enemies", "collects", "objects", "enemyBullets",], solids: ["objects"], tiles: [t, cr], solidTiles: [t] }
    }

    let loc = []
    let size = { x: 300, y: 300 }
    for (i = 0; i < size.y; i++) {
        loc[i] = [];
        for (ii = 0; ii < size.x; ii++) {
            loc[i][ii] = t;
        }
    }
    let lox = []
    //setting that array to be the same size
    for (let i = 0; i < loc.length; i++) {
        lox[i] = [];
        for (let x = 0; x < loc[i].length; x++) {
            lox[i][x] = false
        }
    }

    let levelLevel = -1;

    let zoom = 0.8 * (Math.max(window.innerWidth, window.innerHeight) / 1000);
    scax = (window.innerWidth - (window.innerWidth * zoom)) / 2
    scay = (window.innerHeight - (window.innerHeight * zoom)) / 2
    let lightsCanvas = document.createElement('canvas');
    let lights = makeContext(lightsCanvas, true);
    let ctx = makeContext("canvas", false);
    let ctw = makeContext("wcanvas", false);
    let UI = makeContext("uicanvas", true);
    let wallCanvas = document.getElementById("wcanvas");
    let miniCanvas = document.getElementById("miniMap");
    let miniMap = miniCanvas.getContext('2d');
    miniCanvas.width = size.x * 2;
    miniCanvas.height = size.y * 2;
    miniCanvas.style.left = (window.innerWidth / 2) - (miniCanvas.width / 2) + "px"
    miniCanvas.style.top = (window.innerHeight / 2) - (miniCanvas.height / 2) + "px"

    let tileMapCanvas = document.createElement("canvas");
    tileMapCanvas.width = size.x * 16;
    tileMapCanvas.height = size.y * 16;
    let tileMap = tileMapCanvas.getContext('2d');
    tileMap.imageSmoothingEnabled = false;
    let tileSheet = {
        sheet: imageSRC("prisonTiles.png"),
        key: [67, 102, 9, 6],
        crystalSpikes: [192, 128, 16, 16],
        ammoPickup: [622, 256, 10, 7],
        gunPickup: [622, 263, 9, 7],
        healthBar: [632, 256, 22, 4],
        cursor1: [632, 260, 7, 7],
        cursor2: [639, 260, 7, 7],
        blood1: [654, 256, 8, 8],
        bloodP1: [662, 256, 8, 8],
        money: [645, 264, 4, 4],
        get exit() { return [80 + ((levelLevel - 1) * 128), 112, 48, 48] },
    }

    let blenderAnim = {
        source: tileSheet.sheet,
        animations: {
            0: { current: 0, frames: 1, width: 16, height: 16, speed: 0.1, sheetX: 0, sheetY: 256 },
            1: { current: 0, frames: 5, width: 16, height: 16, speed: 0.1, sheetX: 16, sheetY: 256 },
            2: { current: 0, frames: 5, width: 16, height: 16, speed: 0.1, sheetX: 96, sheetY: 256 },
            3: { current: 0, frames: 5, width: 16, height: 16, speed: 0.1, sheetX: 16 + 160, sheetY: 256 },
            4: { current: 0, frames: 5, width: 16, height: 16, speed: 0.1, sheetX: 16 + 240, sheetY: 256 },
            5: { current: 0, frames: 5, width: 16, height: 16, speed: 0.1, sheetX: 16 + 320, sheetY: 256 },
            6: { current: 0, frames: 5, width: 16, height: 16, speed: 0.1, sheetX: 16 + 400, sheetY: 256 },

        },
        get animOn() { return Math.floor(bioMass / 16) }
    };

    let miniFog = document.createElement('canvas');
    let mapFog = miniFog.getContext('2d');
    miniFog.width = size.x * 2;
    miniFog.height = size.y * 2;

    let floor = document.createElement('canvas');
    floor.width = 192;
    floor.height = 192;

    let mapScale = 25;
    let mapZoom = 3;
    let mapUISize = 5;

    let tutorialOn = 0;
    let tutorialText = [
        ["", false],
        ["this is Gun Knight", true],
        ["Gun Knight likes to shoot things", true],
        ["Press [SpaceBar] to shoot stuff", false],
        ["Gun Knight also likes to aim when he is shooting so he hits the right things", true],
        ["use the mouse to aim", false],
        ["Often times Gun Knight wants to shoot something,", true],
        ["but a wall is in the way,", true],
        ["so he moves to a better spot so that he can shoot stuff", true],
        ["use the WASD keys to move around", false],
        ["that's about it", true],
        ["use exit portal to move to the next level", false],
    ]

    obj.UI.push({
        value: {
            type: "text",
            get text() {
                if (tutorialText[tutorialOn][1] == true)
                    return "(Press Space to continue)"
                else return ""
            }, align: "center", size: 24
        }, x: 0, y: 140, alignX: 0.5, alignY: 0
    })

    UI.fillStyle = "white";
    obj.UI.push({ value: { type: "text", get text() { return tutorialText[tutorialOn][0] }, align: "center", size: 24 }, x: 0, y: 100, alignX: 0.5, alignY: 0 })
    obj.UI.push({ value: { type: "text", get text() { return Math.round(player.health) + "/" + Math.round(player.maxHealth) }, align: "left", size: 16 }, x: 20, y: 40, alignX: 0, alignY: 0 })
    obj.UI.push({ value: { type: "text", get text() { return money }, align: "left", size: 16 }, x: 200, y: 40, alignX: 0, alignY: 0 })
    obj.UI.push({ value: { type: "text", get text() { return Math.round(gunValues[inventory.left.value].energy) }, align: "left", size: 16 }, x: 52, y: -20, alignX: 0, alignY: 1 })
    obj.UI.push({ value: { type: "text", get text() { return Math.round(gunValues[inventory.right.value].energy) }, align: "left", size: 16 }, x: 190, y: -20, alignX: 0, alignY: 1 })
    obj.UI.push({ value: { type: "text", get text() { return Math.round(gunValues[inventory.backup.value].energy) }, align: "left", size: 16 }, x: 340, y: -20, alignX: 0, alignY: 1 })
    obj.UI.push({ value: { type: "text", text: "swap Items: <Q> & <E>", align: "left", size: 8 }, x: 40, y: -100, alignX: 0, alignY: 1 })
    obj.UI.push({ value: { type: "text", get text() { return gunValues[inventory.left.value].name }, align: "left", size: 24 }, x: 40, y: -120, alignX: 0, alignY: 1 })
    obj.UI.push({ value: { type: "text", get text() { return keyCount }, align: "right", size: 16 }, x: -70, y: -30, alignX: 1, alignY: 1 })
    obj.UI.push({
        value: {
            type: "text", get text() {
                if (player.health < 0) {
                    return "you have died :("
                } else {
                    return " "
                }
            }, align: "center", size: 72
        }, x: 0, y: 0, alignX: 0.5, alignY: 0.5
    })

    let keyCount = 0
    pauseMenu = document.getElementById("pauseMenu");
    htmlBody = document.getElementById("body");
    let mapExplored = 0
    let mapAreaTotal = 0
    let speed = 0.3;

    let iFrames = 0.8;
    let iFrameTimer = 0;

    let enemyTimer = 0;
    let rollSpeedCurve = [{ x: 41, y: 1.0834499842325847 }, { x: 360, y: 1.1376999842325848 }, { x: 462, y: 0.621033317565918 }, { x: 503, y: 0.019116650899251304 },]
    let rollTimer = 0;
    let rollTime = 0.35;
    let rollCoolDown = 0.8;
    let rollCoolDownTimer = 0;
    let rollSpeed = 0.6;
    let rollDirection = { x: 0, y: 0 }

    let camShake = {
        get shake() {
            if (this.length > 0 && doScreenShake) {
                this.length -= 0.01;
                return (Math.random() - 0.5) * this.shakeLevel;
            }
            return 0;
        }, shakeLevel: 10, length: 0
    }

    let enemyMax = 15;
    let difficulty = 0
    let totalTime = 0
    let timeInCurrentLevel = 0
    let bioMass = 0
    let shootTimer = 0.0
    let shootSpeed = 0.4
    let money = 0

    let swingTime = 0

    let loadingScreenAlpha = 0
    let instincted = false
    let tutorialDirs = { w: false, a: false, s: false, d: false }
    let portalMadeForTutorial = false;
    let flashLightCharge = 100
    let flashLightSize = 170

    let playerAnim = {
        source: entitySprites,
        animations: {
            stand: { current: 0, frames: 1, width: 11, height: 18, speed: 1, sheetX: 208, sheetY: 0 },
            run: { current: 0, frames: 8, width: 11, height: 18, speed: 90, sheetX: 208, sheetY: 18 },
            roll: { current: 0, frames: 4, width: 11, height: 18, speed: 90, sheetX: 208, sheetY: 36 },
        },
        animOn: "run"
    };
    cam = { x: 0, y: 0 }
    //Tilemap stuff -----------------------------------------------------------------

    nodes = [
        { room: "start", size: 0, edges: [1] },
        { room: "fill", size: 4, edges: [2, 3] },
        { room: "key", size: 4, edges: [] },
        { room: "lock", size: 1, edges: [4, 5] },
        { room: "exit", size: 2, edges: [] },
        { room: "gun", size: 2, edges: [] },
    ]

    debugMode = false // set debug
    collisionDebug = false
    tileDebugMode = false

    function doorTile(x, y, dirx, diry) {
        if (x.x != undefined) {
            this.position = x;
            this.direction = y
        } else {
            this.position = { x: x, y: y };
            this.direction = { x: dirx, y: diry }
        }
    }

    let tryingDungeon = 0
    let generationType = "dungeon crawler"
    //this function is a fancy one with an asterisk so that it can be paused to update the loading screen
    //it does all the things that are needed when you are generating a map.
    //I would like it to be able to generate multiple types of maps, but currently it only does random rooms.
    function* generateLevel() {
        /*
        a note on the yields:
        they return what is going to happen next, not what it is currently doing
        */

        //this part resets all the values so that another map can generate without problems
        tryingDungeon = 0
        gameStarted = false
        yield [0, "Reseting values"]
        yield [2, "Generating map (will probably take a while)"]
        timeInCurrentLevel = 0
        levelLevel++;
        mapFog.fillStyle = "#222222";
        mapFog.globalCompositeOperation = "source-over"
        mapFog.fillRect(0, 0, 1000, 1000)
        mapFog.globalCompositeOperation = "destination-out"

        obj.walls = [];
        obj.enemies = [];
        obj.collects = [];
        obj.tileDebug = [];
        obj.objects = []

        //this part generates the map, it's the part I would like to change to make different types of maps
        switch (generationType) {
            case "dungeon crawler":
                if (levelLevel != 0) {
                    try {
                        loc = dungeonate(loc, levelValues[levelLevel].rooms)
                        loc = sterilizeMap(loc, [n, e, s, w], t)
                        for (i = 0; i < size.y; i++) {
                            for (ii = 0; ii < size.x; ii++) {
                                if (loc[i][ii] == q) {
                                    loc[i][ii] = levelValues[levelLevel].defaultTile;
                                }
                            }
                        }
                    } catch (error) {
                        console.error(error)
                        yield [60, "Giving up on generating a map"]
                    }
                } else {
                    loc = makeRoom(loc, lox, levelValues[0].rooms[0])
                }
                break
            case "set rooms":
                loc = makeRoom(loc, lox, levelValues[levelLevel].rooms[0])//probably want to change this, but it might also work.
                break
        }

        yield [80, "Spawning map stuff / Getting data"]
        console.log("completed level generation")

        yield [82, "Baking the tilemap"]
        //this part spawns in all the tiles that are entities and not just tiles
        loc[0][0] = true
        mapAreaTotal = 0
        for (y = 0; y < loc.length; y++) {
            for (x = 0; x < loc[y].length; x++) {

                if (loc[y][x] == _) mapAreaTotal++
                if (loc[y][x] == d) {
                    obj.collects.push({
                        x: x * 50 + 25, y: y * 50 + 25, type: "upgrade",
                        collect() {
                            currentHealth = Math.pow(100, Math.sqrt(lStats.sneak * 0.01) + Math.sqrt(lStats.arson * 0.008) + Math.sqrt(lStats.health * 0.015) + 1)
                            statInfos = [document.getElementById("sneakStat"), document.getElementById("arsonStat"), document.getElementById("healthStat"),]
                            statNames = ["sneak", "arson", "health"]
                            for (j = 0; j < statInfos.length; j++) {
                                arrayOfStats = [0, 0, 0]
                                if (j == 0) {
                                    arrayOfStats = [1, 0, 0]
                                } else if (j == 1) {
                                    arrayOfStats = [0, 1, 0]
                                } else {
                                    arrayOfStats = [0, 0, 1]
                                }
                                newHealth = Math.pow(100, Math.sqrt((lStats.sneak + arrayOfStats[0]) * 0.01) + Math.sqrt((lStats.arson + arrayOfStats[1]) * 0.008) + Math.sqrt((lStats.health + arrayOfStats[2]) * 0.015) + 1)
                                i = statNames[j]
                                statInfos[j].innerHTML = "Level: " + lStats[i] + " => " + (lStats[i] + 1) +
                                    " <br> Damage: " + (Math.round(Math.pow(1.2, lStats[i]) * 100)) + "% = > " + (Math.round(Math.pow(1.2, lStats[i] + 1) * 100)) + "% <br> " +
                                    "Health + " + Math.round(((newHealth / currentHealth) - 1) * 100) + "%"

                            }
                            openMenu(statUpMenu)
                            statUpPause = true
                        },
                        anim: {
                            source: tileSheet.sheet,
                            animations: {
                                cell: { current: 0, speed: 150, frames: 9, width: 14, height: 16, sheetX: 496, sheetY: 256 }
                            },
                            animOn: "cell"
                        },

                    });
                }

                if (loc[y][x] == "exit") {
                    obj.collects.push({ x: x * 50 + 25, y: y * 50 + 25, type: "exit", collect() { loadLevel() }, });
                }
                if (loc[y][x] == "gun") {
                    obj.collects.push(
                        {
                            x: x * 50 + 25, y: y * 50 + 25,
                            width: 40, height: 40,
                            type: "gun",
                            collect() {
                                gunBeingPickedUp = Math.floor(Math.random() * gunValues.length)
                                canvases = [
                                    document.getElementById("leftGunCanvas").getContext("2d"),
                                    document.getElementById("rightGunCanvas").getContext("2d"),
                                    document.getElementById("backupGunCanvas").getContext("2d"),
                                    document.getElementById("swapGunCanvas").getContext("2d")
                                ]
                                gunBeingDrawn = [
                                    inventory.left.value,
                                    inventory.right.value,
                                    inventory.backup.value,
                                    gunBeingPickedUp
                                ]
                                for (i = 0; i < 4; i++) {
                                    canvases[i].imageSmoothingEnabled = false
                                    canvases[i].clearRect(0, 0, 500, 500)
                                    canvases[i].drawImage(gunSprites, ((gunBeingDrawn[i]) % 8) * 32, Math.floor(gunBeingDrawn[i] / 8) * 16, 32, 16, 0, 0, 300, 150);
                                }
                                openMenu(gunPickupMenu)
                            }
                        });
                }
                if (loc[y][x] == "key") {
                    obj.collects.push(
                        {
                            x: x * 50 + 25,
                            y: y * 50 + 25,
                            width: 27, height: 18,
                            type: "key",
                            collect() {
                                keyCount++
                            }
                        });
                }
                if (loc[y][x] == "lock") {
                    obj.objects.push({
                        x: x * 50 + 25,
                        y: y * 50 + 25,
                        width: 50,
                        height: 50,
                        draw(i) {
                            if (this.type == "lock") {
                                objects.drawImage(tileSheet.sheet, ...[80, 96, 16, 16], obj.objects[i].x + cam.x - 25, obj.objects[i].y + cam.y - 25, 50, 50)
                            } else if (this.type == "unlock") {
                                objects.drawImage(tileSheet.sheet, ...[96, 96, 16, 16], obj.objects[i].x + cam.x - 25, obj.objects[i].y + cam.y - 25, 50, 50)
                            }
                        },
                        update(i) {
                            if (Math.abs(this.x - player.x) < 60 && Math.abs(this.y - player.y) < 60 && keyCount > 0 && this.type == "lock") {
                                keyCount--
                                this.type = "unlock"
                                this.solid = false
                            }
                        },
                        type: "lock",
                    })
                }
                if (loc[y][x] == "crate") {
                    obj.objects.push({
                        x: x * 50 + 25,
                        y: y * 50 + 25,
                        width: 50,
                        height: 50,
                        health: 3,
                        noKnockBack: true,
                        draw(i) {
                            objects.drawImage(tileSheet.sheet, 64, 112, 16, 16, obj.objects[i].x + cam.x - 25, obj.objects[i].y + cam.y - 25, 50, 50)
                        },
                        update(i) {

                            if (this.health <= 0) {
                                obj.objects.splice(i, 1)
                            }
                        },
                        onCollision(col) {
                            if (col.collision == "bullet") {
                                this.health--
                            }
                        },
                        type: "crate",
                    })
                }
                if (loc[y][x] == "spawn") {
                    player.x = x * 50 + 25;
                    player.y = y * 50 + 25;
                }
            }
        }

        if (levelLevel == 0) {
            player.x = 50 + 25;
            player.y = 50 + 25;
        } else {

        }

        // a bunch of complicated nested for loops that draw the tilemap with rule tiles

        yield [90, "Drawing the floor"]
        tileMap.clearRect(0, 0, tileMapCanvas.width, tileMapCanvas.height)
        for (let y = 0; y < loc.length; y++) {
            for (let x = 0; x < loc[y].length; x++) {
                if (loc[y][x] == "crystal") {
                    tileMap.drawImage(tileSheet.sheet, ...tileSheet.crystalSpikes, x * 16, y * 16, 16, 16);
                }
                let currentTile = []
                for (let py = -1; py < 2; py++) {
                    currentTile[py + 1] = []
                    for (let px = -1; px < 2; px++) {
                        if (!(x + px < 0 || x + px + 1 > loc[0].length || y + py + 1 > loc.length || y + py < 0)) {
                            currentTile[py + 1][px + 1] = loc[y + py][x + px]
                            if (currentTile[py + 1][px + 1] != t && currentTile[py + 1][px + 1] != _) {
                                currentTile[py + 1][px + 1] = _;
                            }
                        } else {
                            currentTile[py + 1][px + 1] = t
                        }
                    }
                }

                for (i = 0; i < ruleTiles.length; i++) {
                    match = true;
                    for (let py = 0; py < 3; py++) {
                        for (let px = 0; px < 3; px++) {
                            if (ruleTiles[i][py][px] != currentTile[py][px] && ruleTiles[i][py][px] != q) {
                                match = false;
                            }
                        }
                    }
                    if (match) {
                        xile = 0
                        yile = 0
                        for (let px = 0; px < i; px++) {
                            xile++;
                            if (xile > 7) {
                                xile = 0;
                                yile++;
                            }

                        }
                        tileMap.drawImage(tileSheet.sheet, xile * 16 + ((Math.max(levelLevel - 1, 0)) * 128), yile * 16, 16, 16, x * 16, y * 16, 16, 16);
                    }
                }
            }
        }

        yield [91, "Baking collisions"]
        //drawing the new floor
        floorctx = floor.getContext('2d')
        floorctx.imageSmoothingEnabled = false
        floorctx.drawImage(tileSheet.sheet, (Math.max(levelLevel - 1, 0)) * 128, 96, 64, 64, 0, 0, 192, 192)
        //setting that array to be the same size
        for (let i = 0; i < loc.length; i++) {
            lox[i] = [];
            for (let x = 0; x < loc[i].length; x++) {
                lox[i][x] = false
            }
        }

        //this will run for each row of tiles in the tilemap
        for (let y = 0; y < loc.length; y++) {
            //checking it for each tile in the row
            for (let x = 0; x < loc[y].length; x++) {
                //check a position to see if there is a tile there
                if (loc[y][x] == true && lox[y][x] == false) {
                    //if so, mark it as checked, then check the next tile in the row, and see how long the line is
                    lox[y][x] = true;
                    //this stores the length of the line of tiles
                    let length = x;
                    while (loc[y][length] == true) {
                        lox[y][length] = true;
                        length++;
                    }
                    //this array will store the height of the line at every point along the line
                    let height = [];
                    //check the spot at each point along the line
                    for (let check = 0; check < length - x; check++) {
                        //first set the height to zero
                        height[check] = 0;
                        let fail = true;
                        //check the tiles downwards in a row, and make sure I'm not checkign off the side of the tilemap

                        while (loc[height[check] + y][check + x] == true && fail) {
                            //make sure that I'm not checking an area outside the tilemap
                            if (height[check] + y != loc.length - 1) {
                                height[check]++;
                            } else {
                                //If I am, end the loop
                                fail = false;
                            }
                        }
                    }
                    //set each tile as checked for the minimum height
                    for (let check = 0; check < length - x; check++) {
                        for (let j = 0; j < Math.min.apply(null, height); j++) {
                            lox[j + y][check + x] = true;
                        }
                    }

                    //finally, create a collision box with the dimensions that have been found
                    let bb = { x: 0, y: 0, width: 0, height: 0, collision: "wall" }
                    bb.width = (length - x) * 50;
                    bb.height = (Math.min.apply(null, height) * 50);
                    bb.x = (x * 50) + (bb.width / 2);
                    bb.y = (y * 50) + (bb.height / 2);
                    obj.walls.push(bb);
                }
            }
        }
        yield [99.99, "Telling the game to start itself"]
        gameStarted = true;
        loadingScreen = false
        paused = false
        loadingMenu.style.display = "none"
        yield [100, "Done!"]

    }
    loadingScreen = false
    loadlvl = generateLevel(0)
    let loadingScreenIMG = imageSRC("https://codehs.com/uploads/3fa720c8fe388cf59feea201ed615f8c")
    let loadingText = ""
    let loadingTitle = ""
    function loadLevel() {
        paused = true
        loadingScreen = true
        loadingMenu.style.display = "inline"
        loadingText = levelValues[levelLevel + 1].loadingText[Math.floor(Math.random() * levelValues[levelLevel + 1].loadingText.length)]
        loadingTitle = levelValues[levelLevel + 1].name
        document.getElementById("proDes").innerHTML = "Loading..."
        document.getElementById("barPart").style.width = "0%"
        setTimeout(loadLevelRecurse, 1000)
    }

    function loadLevelRecurse() {
        message = loadlvl.next().value;
        document.getElementById("proDes").innerHTML = message[1]
        document.getElementById("barPart").style.width = message[0] + "%"
        if (message[0] < 100) {
            setTimeout(loadLevelRecurse, message[2] || 10)
        } else {
            loadlvl = generateLevel(0)
            body.style.cursor = "none"
            document.getElementById("canvases").style.display = "inline";
            document.getElementById("startMenu").style.display = "none";
        }

    }

    function dungeonate(loc, rooms) {
        nodes = levelValues[levelLevel].nodes
        obj.tileDebug = [];
        //reseting the dungeon map
        for (i = 0; i < size.y; i++) {
            loc[i] = [];
            lox[i] = [];
            for (ii = 0; ii < size.x; ii++) {
                loc[i][ii] = q;
                lox[i][ii] = false;
            }
        }
        let node = createDungeonNode({ position: { x: 150, y: 10 }, direction: { x: 0, y: 1 } }, nodes[0], rooms)
        loc = makeRoom(loc, lox, node.map)
        let edgeArray = node.edges(nodes[0].edges.length)
        for (ed = 0; ed < edgeArray.length; ed++) {
            obj.tileDebug.push({ x: edgeArray[ed].x, y: edgeArray[ed].y, text: "starting edge" + edgeArray.length, color: "rgba(255, 255, 255, 0.4)" })
            itterateNodes(nodes[0].edges[ed], edgeArray[ed], rooms, 0)
        }
        return loc
    }

    function itterateNodes(nodeOn, edge, rooms, attempts) {
        try {
            let node = createDungeonNode(new doorTile(addVector(edge, edge.type), edge.type), nodes[nodeOn], rooms)
            loc = makeRoom(loc, lox, node.map, edge, negVector(edge))
            let edgeArray = node.edges(nodes[nodeOn].edges.length)

            if (edgeArray.length > 0) {
                for (ed = 0; ed < edgeArray.length; ed++) {
                    itterateNodes(
                        nodes[nodeOn].edges[ed],
                        edgeArray[ed],
                        rooms,
                        0
                    )
                }
            }
        }
        catch (error) {
            console.log("node itteration attempt: " + attempts)
            console.log(error)
            if (attempts < 2) {
                itterateNodes(nodeOn, edge, rooms, attempts + 1)
            } else {
                console.count("reset generation")
                console.log("failed to itterate a node")
                tryingDungeon++
                loc = dungeonate(loc, levelValues[levelLevel].rooms)
            }
        }
    }

    function createDungeonNode(start, node, rooms) {
        nodeMap = {
            map: Array.from({ length: size.y }).map((x) => Array.from({ length: size.x }).map((x) => q)),
            eval: Array.from({ length: size.y }).map((x) => Array.from({ length: size.x }).map((x) => false)),
            startTile: start,

            edges(edgeCount) {
                edges = findTiles(this.map, [n, e, s, w])

                edges.forEach((edge, j) => {
                    valid = true
                    gotToEdge = false
                    if (edge == this.startTile) {
                        valid = false
                    }
                    for (i = 0; valid && !gotToEdge; i++) {
                        testPoint = { x: edge.x + (edge.type.x * i), y: edge.y + (edge.type.y * i) }
                        if (testPoint.x > this.map[0].length - 1 || testPoint.x < 0 || testPoint.y > this.map.length - 1 || testPoint.y < 0) {
                            if (this.map[testPoint][testPoint] == _) {
                                valid = false;
                            }
                        } else {
                            gotToEdge = true;
                        }

                    }
                    if (!valid) {
                        edges.splice(j, 1)
                    }
                })

                while (edges.length > edgeCount) {
                    edges.splice(0, 1)
                }

                return edges;
            },

            makeRoom(room, start, door, n) {
                mapMade = makeRoom(this.map, this.eval, room, start, n, door)
                this.map = mapMade
            },
            iterateOrients(rooms, attempt) {
                let start = null
                checkFor = null
                map = this.map
                checkFors = [n, e, s, w]
                found = false
                for (i = 0; i < 4 && found == false; i++) {
                    randCheck = Math.floor(checkFors.length * Math.random())
                    checkFor = checkFors[randCheck]
                    tile = findTile(map, checkFor)

                    if (tile != null) {
                        start = tile
                        found = true
                        i = 4
                    }
                    checkFors.splice(randCheck, 1)
                }
                opposite = null
                switch (checkFor) {
                    case n: opposite = s
                        break;
                    case e: opposite = w
                        break;
                    case s: opposite = n
                        break;
                    case w: opposite = e
                        break;
                }
                roomValues = findRoom(rooms, opposite) || [rooms]
                if (roomValues[0] != null && start != null) {
                    try {
                        this.makeRoom(roomValues[1], start, roomValues[0], checkFor)
                    } catch (error) {
                        console.log(error)
                        if (attempt < 0) {
                            this.iterateOrients(rooms, attempt + 1)
                        } else {
                            throw "iteration failed, probably was stuck in a corner"
                        }
                    }
                }
            },
        }

        if (node.room == "start") {
            nodeMap.makeRoom(levelValues[levelLevel].specialRooms[0], start.position, { x: 0, y: 0 }, start.direction)
            return nodeMap
        }
        sroom = findRoom(rooms, negVector(start.direction))
        nodeMap.makeRoom(sroom[1], start.position, sroom[0], start.direction)

        for (f = 0; f < node.size; f++) {
            nodeMap.iterateOrients(rooms, 0);
        }
        // a bit that generates special rooms,
        if (node.room != "fill") {
            nodeList = null
            if (node.room == "exit") {
                nodeList = [levelValues[levelLevel].specialRooms[1], levelValues[levelLevel].specialRooms[2], levelValues[levelLevel].specialRooms[3], levelValues[levelLevel].specialRooms[4]]
            } else if (node.room == "lock") {
                nodeList = [levelValues[levelLevel].specialRooms[5], levelValues[levelLevel].specialRooms[6]]
            } else if (node.room == "key") {
                nodeList = [levelValues[levelLevel].specialRooms[7], levelValues[levelLevel].specialRooms[8]]
            } else if (node.room == "gun") {
                nodeList = [levelValues[levelLevel].specialRooms[9], levelValues[levelLevel].specialRooms[10]]
            }
            try {
                thisStart = findTile(nodeMap.map, [n, e, s, w])
                if (node.room == "lock") {
                    nodeMap.map = sterilizeMap(nodeMap.map, [n, e, s, w], t)
                }
                nodeMap.map[thisStart.y][thisStart.x] = thisStart.type
                roomValues = findRoom(nodeList, negVector(thisStart.type))
                nodeMap.makeRoom(roomValues[1], thisStart, roomValues[0], thisStart.type)
            } catch (error) {
                console.error(error)
                throw "special room crapped itself"
            }

            if (node.room == "exit") {
                return nodeMap
            }

            if (findTile(nodeMap.map, node.room) == null) {
                throw "special room crapped itself"
            }
        }

        // the part that makes the general dungeon
        if (nodeMap.edges(node.edges.length).length < node.edges.length) {
            for (f = 0; nodeMap.edges(node.edges.length).length < node.edges.length && f < 30; f++) {
                nodeMap.iterateOrients(rooms, 0);
            }
        }
        return nodeMap
    }

    //finds a room with a specific tile in a set of rooms
    function findRoom(roms, find) {
        let validRooms = [];
        for (i = 0; i < roms.length; i++) {
            tile = findTile(roms[i], find)
            if (tile != null) {
                validRooms.push([tile, roms[i]])
            }
        }
        return validRooms[Math.floor(Math.random() * validRooms.length)]
    }
    //finds a specific tile in a room
    function findTile(r, find) {
        found = false;
        x = 0;
        y = 0;
        while (!found) {
            if (y > r.length - 1) {
                return null;
            } else if (Array.isArray(find)) {
                for (i = 0; i < find.length && !found; i++) {
                    if (vectorEquals(r[y][x], find[i])) {
                        return { x: x, y: y, type: find[i] };
                    }
                }
                if (!found) {
                    x++;
                    if (x > r[y].length - 1) {
                        x = 0;
                        y++;
                    }
                }
            } else {

                if (vectorEquals(r[y][x], find) || r[y][x] == find) {
                    found = true;
                } else {
                    x++;
                    if (x > r[y].length - 1) {
                        x = 0;
                        y++;
                    }
                }
            }
        }
        return { x: x, y: y };
    }
    //finds every instance of that tile in a room
    function findTiles(r, find) {
        found = false;
        x = 0;
        y = 0;
        tilesFound = []
        while (true) {
            if (y > r.length - 1) {
                return tilesFound;
            } else if (Array.isArray(find)) {
                for (i = 0; i < find.length && !found; i++) {
                    if (r[y][x] == find[i]) {
                        tilesFound.push({ x: x, y: y, type: find[i] })
                    }
                }
                if (!found) {
                    x++;
                    if (x > r[y].length - 1) {
                        x = 0;
                        y++;
                    }
                }
            } else {
                if (r[y][x] == find) {
                    tilesFound.push({ x: x, y: y, direction: { x: find[i].x, y: find[i].y } })
                } else {
                    x++;
                    if (x > r[y].length - 1) {
                        x = 0;
                        y++;
                    }
                }
            }

        }
    }

    function makeRoom(map, testMap, room, start, n, door) {
        // door is optional
        start = start || { x: 0, y: 0 }
        n = n || { x: 0, y: 0 }
        x = start.x + n.x - (door?.x || 0)
        y = start.y + n.y - (door?.y || 0)

        for (i = 0; i < room.length; i++) {
            for (ii = 0; ii < room[i].length; ii++) {
                if (i + y > map.length - 1 || i + y < 0 || ii + x > map[0].length - 1 || ii + x < 0) {
                    throw "the room you are trying to generate goes off the map, and therefore isn't valid"
                }
                if (testMap[i + y][ii + x] == true && room[i][ii] != q) {
                    throw "the room you are trying to generate is overlapping with another room"
                }
            }
        }
        for (i = 0; i < room.length; i++) {
            for (ii = 0; ii < room[i].length; ii++) {
                if (room[i][ii] != q) {
                    map[i + y][ii + x] = room[i][ii];
                    testMap[i + y][ii + x] = true;
                    if (tileDebugMode) {
                        obj.tileDebug.push({ x: ii + x, y: y + i, text: JSON.stringify(map[i + y][ii + x]) || "bleep", color: "rgba(100, 10, 10, 0.2)" })
                    }
                }
            }
        }
        // making the room connect to the other rooms
        map[start.y][start.x] = _;
        map[start.y + n.y][start.x + n.x] = _;

        return map;
    }

    //goes through a map and replaces all tiles listed as a pathogen with a default tile
    function sterilizeMap(map, pathogens, defaultTile) {
        if (!(pathogens instanceof Array)) {
            pathogens = [pathogens]
        }
        defaultTile = defaultTile || _
        for (y = 0; y < map.length; y++) {
            for (x = 0; x < map[y].length; x++) {
                for (p = 0; p < pathogens.length; p++) {
                    if (map[y][x] == pathogens[p]) {
                        map[y][x] = defaultTile
                    }
                }
            }
        }
        return map
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';

        for (var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = context.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = testLine;
            }
        }
        context.fillText(line, x, y);
    }

    function makeContext(name, overlay) {
        canvas = document.getElementById(name) || name
        canvas.style.top = "0px";
        canvas.style.left = "0px";

        canvas.width = Math.max(window.screen.width, window.screen.height) /// zoom
        canvas.height = Math.max(window.screen.width, window.screen.height)// / zoom

        cont = canvas.getContext('2d');
        cont.imageSmoothingEnabled = false;
        if (!overlay) cont.setTransform(zoom, 0, 0, zoom, scax, scay);
        return cont;
    }

    //input variables
    let inputVector = {
        get x() {
            if (inputVector.s - inputVector.w != 0) {
                this.setPrev(0.7)
                return (inputVector.d - inputVector.a) * 0.75
            }
            this.setPrev(1)
            return inputVector.d - inputVector.a
        },
        get y() {
            if (inputVector.d - inputVector.a != 0) {
                return (inputVector.s - inputVector.w) * 0.75
                this.setPrev(0.7)
            }
            this.setPrev(1)
            return inputVector.s - inputVector.w
        },
        setPrev(mult) {
            if (inputVector.s - inputVector.w != 0 || inputVector.d - inputVector.a != 0) {
                this.xPrev = (this.d - this.a) * mult
                this.yPrev = (this.s - this.w) * mult
            }
        },
        xPrev: 1, yPrev: 1, "w": 0, "a": 0, "s": 0, "d": 0,
    };
    let mouse = { get x() { return mouse.mx - cam.x }, get y() { return mouse.my - cam.y }, mx: 0, my: 0 }
    let shootLeft = false;
    let shootRight = false;
    let roll = false;
    let aimPoint = { x: 0, y: 0, locked: false }
    let aimLock = false;
    let paused = false;

    let inpFunct = {
        shootLeft: {
            down() {
                if (levelLevel == 0 && tutorialText[tutorialOn][1] == true) {
                    tutorialOn++;
                } else {
                    shootLeft = true;
                }
            },
            up() {
                shootLeft = false;
            }
        },

        shootRight: {
            down() {
                if (levelLevel == 0 && tutorialText[tutorialOn][1] == true) {
                    tutorialOn++;
                } else {
                    shootRight = true;
                }
            },
            up() {
                shootRight = false;
            }
        },

        left: {
            down() {
                inputVector.a = 1
            },
            up() {
                inputVector.a = 0
            }
        },
        right: {
            down() {
                inputVector.d = 1
            },
            up() {
                inputVector.d = 0
            }
        },
        up: {
            down() {
                inputVector.w = 1
            },
            up() {
                inputVector.w = 0
            }
        },
        down: {
            down() {
                inputVector.s = 1
            },
            up() {
                inputVector.s = 0
            }
        },
        roll: {
            down() {
                roll = true;
            },
            up() {
                roll = false;
            }
        },
        cycleGuns: {
            down() {
                gunLeft = inventory.left
                gunRight = inventory.right
                inventory.left = gunRight
                inventory.right = gunLeft
            },
        },
        backPackGun: {
            down() {
                gunLeft = inventory.left
                gunRight = inventory.backup
                inventory.left = gunRight
                inventory.backup = gunLeft
            },
        },
        debugCycleGuns: {
            down() {
                if (debugMode) {
                    inventory.left++;
                    if (inventory.left >= gunValues.length) {
                        inventory.left = 0
                    }
                }
            }
        },
        activateCollisionDebug: {
            down() {
                collisionDebug = !collisionDebug
            }
        },
        fullScreenMap: {
            down() {
                miniCanvas.style.opacity = 0.99
            },
            up() {
                miniCanvas.style.opacity = 0
            }
        },
        flashLight: {
            down() {
                if (flashLightCharge > 0 && flashLightSize < 300) {
                    flashLightCharge -= 5
                    flashLightSize += 50
                }
            }
        },
        pause: {
            up() {
                paused = !paused;
                if (paused) {
                    //pauseMenu.style.display = "inline"
                    //body.style.cursor = "auto"
                } else {
                    rightClickEnabled = document.querySelector("#enableRightClick").checked;
                    customMouse = !document.querySelector("#customMouse").checked;
                    doScreenShake = !document.querySelector("#disableScreenShake").checked;
                    if (document.querySelector("#gore").checked) {
                        goreLevel = 0;
                    } else if (document.querySelector("#cartoonGore").checked) {
                        goreLevel = 1;
                    } else {
                        goreLevel = 2;
                    }

                    pauseMenu.style.display = "none"
                    if (customMouse) {
                        body.style.cursor = "none"
                    }
                }
            }
        },
    }

    let inputMap = {
        "a": "left",
        "d": "right",
        "s": "down",
        "w": "up",
        "e": "cycleGuns",
        "q": "backPackGun",
        " ": "shootLeft",
        "shift": "roll",
        "t": "flashLight",
        "m": "fullScreenMap",
        "h": "debugCycleGuns",
        "f10": "activateCollisionDebug",
        "leftClick": "shootRight",
    }

    //getting Input for keys
    window.addEventListener("keydown", function (event) {
        if (gameStarted) {
            if (event.defaultPrevented) return;
            let key = event.key.toLowerCase()
            console.log(key)
            inpFunct[inputMap[key]].down()
            event.preventDefault();
        }
    }, true);

    window.addEventListener("keyup", function (event) {
        if (gameStarted) {
            if (event.defaultPrevented) return;
            let key = event.key.toLowerCase()
            inpFunct[inputMap[key]].up()
            event.preventDefault();
        }
    }, true);
    //getting Input for the mouse

    document.body.onmousedown = function () { if (gameStarted) { inpFunct[inputMap.leftClick].down() } }
    document.body.onmouseup = function () { if (gameStarted) { inpFunct[inputMap.leftClick].up() } }

    document.onmousemove = function (event) {
        event = event || window.event;

        if (event.pageX == null && event.clientX != null) {
            eventDoc = (event.target && event.target.ownerDocument) || document;
            doc = eventDoc.documentElement;
            body = eventDoc.body;

            event.pageX = event.clientX +
                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                (doc && doc.clientLeft || body && body.clientLeft || 0);
            event.pageY = event.clientY +
                (doc && doc.scrollTop || body && body.scrollTop || 0) -
                (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (levelLevel != 0 || tutorialOn > 4) {
            mouse.mx = event.pageX;
            mouse.my = event.pageY;
        }
    }

    window.addEventListener('contextmenu', (event) => {
        if (!rightClickEnabled) {
            //event.preventDefault()
        }
    })

    //Loop stuff --------------------------------------------------------------------
    function update() {

        if (levelLevel == 0) {
            tutorial()
        } else {
            for (i = 0; i < obj.objects.length; i++) {
                obj.objects[i].update(i)
            }
            explorersInstinct()

            if (player.health > 0) {
                playerMove();

                collectItemLoop();

                enemyLoop();

                shootLoop();

                playerRender();

                for (i = 0; i < obj.enemyBullets.length; i++) {
                    light(obj.enemyBullets[i].x, obj.enemyBullets[i].y, 75, 1);
                    units = unitVector(obj.enemyBullets[i].velX, obj.enemyBullets[i].velY);
                    rot = Math.atan2(units.y, units.x)
                    objects.save();
                    objects.translate(obj.enemyBullets[i].x + cam.x, obj.enemyBullets[i].y + cam.y);
                    objects.rotate(rot);
                    objects.drawImage(gunSprites, 448, 16, 32, 16, -48, -24, 96, 48);
                    objects.restore();
                    b = obj.enemyBullets[i]

                    let x = Math.min(progress, 10)
                    addPos(b.velX * x, b.velY * x, b);

                    if (b.x > (loc[0].length * 50) + 50 || b.x < -50 || b.y > (loc.length * 50) + 50 || b.y < - 50) {
                        obj.enemyBullets.splice(i, 1);
                    }
                }
            }
        }
    }

    function drawUI() {
        UI.clearRect(0, 0, window.innerWidth, window.innerHeight);
        UI.globalAlpha = 1;
        UI.shadowOffsetX = 0;
        UI.shadowOffsetY = 0;
        UI.shadowBlur = 0

        if (gameStarted) {
            //drawing the miniMap
            miniMap.fillStyle = '#00fff0';
            miniMap.fillRect(player.x / mapScale - (mapScale / 50), player.y / mapScale - (mapScale / 50), 1 / (mapScale / 50), 1 / (mapScale / 50))
            mapFog.beginPath();
            mapFog.arc(player.x / mapScale, player.y / mapScale, 20, 0, 2 * Math.PI, false);
            mapFog.fill();
            if (!debugMode) {
                miniMap.drawImage(miniFog, 0, 0);
            }
            for (i = 0; i < obj.collects.length; i++) {
                if (obj.collects[i].type == "exit") {
                    miniMap.fillStyle = '#9052bc';
                    miniMap.fillRect(obj.collects[i].x / mapScale - (mapScale / 50), obj.collects[i].y / mapScale - (mapScale / 50), 1 / (mapScale / 50), 1 / (mapScale / 50))
                }
            }

            UI.drawImage(
                miniCanvas,
                ((-cam.x + (window.innerWidth / 2)) - (window.innerWidth / 2 * mapZoom)) / mapScale,
                ((-cam.y + (window.innerHeight / 2)) - (window.innerHeight / 2 * mapZoom)) / mapScale,
                window.innerWidth / mapScale * mapZoom,
                window.innerHeight / mapScale * mapZoom,
                window.innerWidth - (window.innerWidth / mapScale * 5) - 20, 20, window.innerWidth / mapScale * 5, window.innerHeight / mapScale * 5
            );

            UI.fillStyle = "#ff0000"
            UI.fillRect(72.5, 55, 150 * (player.health / player.maxHealth), 30);
            UI.fillStyle = "#0000ff"
            UI.fillRect(72.5, 90, 150 * (flashLightCharge / 100), 30);
            UI.fillStyle = "#ffffff"
            UI.drawImage(tileSheet.sheet, ...tileSheet.healthBar, 65, 55, 165, 30);
            UI.drawImage(tileSheet.sheet, ...tileSheet.healthBar, 65, 90, 165, 30);

            animate(UI, 16, 120, blenderAnim, 64, 64)
            for (u = 0; u < obj.UI.length; u++) {
                if (obj.UI[u].value.type == "text") {
                    UI.textAlign = obj.UI[u].value.align;
                    UI.font = obj.UI[u].value.size + 'px "Press Start 2P"'
                    UI.fillText(obj.UI[u].value.text, obj.UI[u].x + (window.innerWidth * obj.UI[u].alignX), obj.UI[u].y + (window.innerHeight * obj.UI[u].alignY))
                }
            }
            UI.drawImage(tileSheet.sheet, ...tileSheet.key, window.innerWidth - 50, window.innerHeight - 50, 27, 16)
            drawPoses = [52, 190, 340]
            slots = ["left", "right", "backup"]
            for (i = 0; i < slots.length; i++) {
                if (inventory[slots[i]].type != "none") {
                    UI.drawImage(gunSprites, ((inventory[slots[i]].value) % 8) * 32, Math.floor(inventory[slots[i]].value / 8) * 16, 32, 16, drawPoses[i], window.innerHeight - 120, 192, 96);
                }
            }

            if (aimLock && aimPoint.locked == true) {
                UI.drawImage(tileSheet.sheet, ...tileSheet.cursor1,
                    (aimPoint.x + cam.x - 15) - (scax / zoom), (aimPoint.y + cam.y - 15) - (scay / zoom), 30, 30)
                if (customMouse) {
                    UI.drawImage(tileSheet.sheet, ...tileSheet.cursor2,
                        (mouse.x + cam.x - 15), (mouse.y + cam.y - 15), 30, 30)
                }
            } else if (customMouse) {
                UI.drawImage(tileSheet.sheet, ...tileSheet.cursor1, (mouse.x + cam.x - 15), (mouse.y + cam.y - 15), 30, 30)
            }

            if (paused) {
                UI.fillStyle = "rgba(20, 20, 20, 0.8)"
                UI.fillRect(0, 0, 4000, 4000)
            }

            if (statUpPause) {
                gunCircleCenter = { x: window.innerWidth / 2, y: window.innerHeight + 800 }
                rotAdd = 0.05
                statCols = [
                    [39, 137, 205],
                    [241, 100, 31],
                    [196, 241, 41],
                ]
                for (i = 0; i < gunValues.length; i++) {
                    yOff = 1000
                    dist = (Math.ceil((i + 1) / 6) * 100) + 1000
                    roti = ((i % 6) * Math.PI * rotAdd) + (Math.PI * 1.5) - (2.5 * Math.PI * rotAdd)

                    extArr = []
                    gunValues[i].stats.forEach((element, i) => { if (element != 0) extArr.push(i) });

                    if (inventory.left == i || inventory.right == i || inventory.backup == i) {
                        yOff = 0
                    }

                    UI.shadowOffsetX = 0;
                    UI.shadowOffsetY = -yOff;
                    UI.shadowBlur = 15;
                    for (ii = 0; ii < extArr.length; ii++) {
                        UI.shadowColor = 'rgba(' + (statCols[extArr[ii]][0]) + ', ' + (statCols[extArr[ii]][1]) + ', ' + (statCols[extArr[ii]][2]) + ', 1)';
                        UI.drawImage(
                            gunSprites, (i % 8) * 32 + (ii * 32 / extArr.length), Math.floor(i / 8) * 16, 32 / extArr.length, 16,
                            (Math.cos(roti) * dist) + gunCircleCenter.x - 96 + (ii * 192 / extArr.length), (Math.sin(roti) * dist) + gunCircleCenter.y - 48 + yOff,
                            192 / extArr.length, 96
                        );
                    }

                    if (inventory.left != i && inventory.right != i && inventory.backup != i) {
                        UI.shadowBlur = 0;
                        UI.shadowColor = 'black';

                        UI.drawImage(
                            gunSprites, (i % 8) * 32, Math.floor(i / 8) * 16, 32, 16,
                            (Math.cos(roti) * dist) + gunCircleCenter.x - 96, (Math.sin(roti) * dist) + gunCircleCenter.y - 48 + yOff,
                            192, 96
                        );
                    }
                }
            }
        }

        if (loadingScreen) {
            loadingScreenAlpha += progress / 1000
            loadingScreenAlpha = Math.min(loadingScreenAlpha, 1)
            UI.globalAlpha = loadingScreenAlpha
            loadingMenu.style.opacity = loadingScreenAlpha
            UI.drawImage(loadingScreenIMG, 0, 0, window.innerWidth, window.innerHeight)
            UI.textAlign = "center"
            UI.font = 16 + 'px "Press Start 2P"'
            UI.fillText(loadingText, window.innerWidth / 2, window.innerHeight - 200)
            UI.font = 32 + 'px "Press Start 2P"'
            UI.fillText(loadingTitle, window.innerWidth / 2, window.innerHeight - 300)
        } else {
            loadingScreenAlpha = 0
            loadingMenu.style.opacity = loadingScreenAlpha
        }
    }

    function draw() {

        //reseting all of the stuff
        lights.globalCompositeOperation = "source-over"
        lights.fillStyle = "#14121d";
        lights.fillRect(-10000, -10000, 20000, 20000);
        cam.x = -player.x + (window.innerWidth * 0.6) - (mouse.mx / 5) + camShake.shake + (scax / zoom);
        cam.y = -player.y + (window.innerHeight * 0.6) - (mouse.my / 5) + camShake.shake + (scay / zoom);
        if (!debugMode) {
            cam = clamp2(cam, (-loc[0].length * 50) - (-window.innerWidth), 0, (-loc.length * 50) - (-window.innerHeight), 0)
        }

        let units = unitVector(aimPoint.x - player.x, aimPoint.y - player.y);
        let rot = Math.atan2(units.y, units.x)
        type = null
        if (inventory.left.type == "gun") type = gunValues[inventory.left.value];
        if (inventory.left.type == "sword") type = swordValues[inventory.left.value];
        type.render(rot, units);

        miniMap.fillStyle = '#ffffff';

        miniMap.fillRect(0, 0, loc[0].length / (mapScale / 50), loc.length / (mapScale / 50) - 5);
        for (i = 0; i < obj.walls.length; i++) {
            miniMap.fillStyle = '#000000';
            miniMap.fillRect((obj.walls[i].x - (obj.walls[i].width / 2)) / mapScale, (obj.walls[i].y - (obj.walls[i].height / 2)) / mapScale, obj.walls[i].width / mapScale, obj.walls[i].height / mapScale);
        }

        if (tileDebugMode) {
            for (i = 0; i < obj.tileDebug.length; i++) {
                ctw.fillStyle = obj.tileDebug[i].color;
                ctw.fillRect(obj.tileDebug[i].x * 50 + cam.x, obj.tileDebug[i].y * 50 + cam.y, 50, 50);
                ctw.fillStyle = "white";
                wrapText(ctw, obj.tileDebug[i].text, obj.tileDebug[i].x * 50 + cam.x, obj.tileDebug[i].y * 50 + cam.y, 50, 16)
            }
        }

        // Drawing The Floor
        ctx.setTransform(zoom, 0, 0, zoom, cam.x * zoom, cam.y * zoom);
        ctx.fillStyle = ctx.createPattern(floor, "repeat");
        ctx.fillRect(0, 0, loc[0].length * 50, loc.length * 50);
        ctx.setTransform(zoom, 0, 0, zoom, scax, scay);

        //drawing Blood splats
        if (goreLevel > 0) {
            for (i = 0; i < obj.splatters.length; i++) {
                obj.splatters[i].fade -= progress / 3000;
                if (obj.splatters[i].fade < 0) obj.splatters.splice(i, 1);
                else {
                    ctx.globalAlpha = Math.min(obj.splatters[i].fade, 1);
                    if (goreLevel == 1) {
                        drawRotatedImage(tileSheet.sheet, obj.splatters[i].x, obj.splatters[i].y, obj.splatters[i].rotate, 0, 0, ctx, 48, 48, tileSheet.bloodP1,);
                    } else {
                        drawRotatedImage(tileSheet.sheet, obj.splatters[i].x, obj.splatters[i].y, obj.splatters[i].rotate, 0, 0, ctx, 48, 48, tileSheet.blood1,);
                    }

                    miniMap.fillStyle = "#b25266"
                    miniMap.fillRect(
                        Math.round((obj.splatters[i].x - 0.5 / (mapScale / 50)) / mapScale),
                        Math.round((obj.splatters[i].y - 0.5 / (mapScale / 50)) / mapScale),
                        1 / (mapScale / 50),
                        1 / (mapScale / 50)
                    );
                }
            }
        }
        ctx.globalAlpha = 1;
        playerRender();

        for (i = 0; i < obj.bullets.length; i++) {
            light(obj.bullets[i].x, obj.bullets[i].y, 75, 1);
            rot = Math.atan2(obj.bullets[i].velY, obj.bullets[i].velX)
            drawRotatedImage(gunSprites, obj.bullets[i].x, obj.bullets[i].y, rot, 0, 0, objects, 96, 48, [((obj.bullets[i].type % 8) * 32) + 256, Math.floor(obj.bullets[i].type / 8) * 16, 32, 16,])
        }
        animate(objects, player.x - (player.width / 2) + cam.x, player.y - (player.height / 2) + cam.y, playerAnim, player.width + 5, player.height + 10, inputVector.x, 1);

        ctx.drawImage(tileMapCanvas, -cam.x * (16 / 50), -cam.y * (16 / 50), window.innerWidth / zoom * (16 / 50), window.innerHeight / zoom * (16 / 50), -scax / zoom, -scay / zoom, window.innerWidth / zoom, window.innerHeight / zoom);

        if (loc[Math.floor(player.y / 50)][Math.floor(player.x / 50)] == "dark") {
            brightness += progress / 1000
        } else if (loc[Math.floor(player.y / 50)][Math.floor(player.x / 50)] == false) {
            brightness -= progress / 1000
        }
        brightness = clamp(brightness, 0.5, 1)

        for (i = 0; i < obj.objects.length; i++) {
            obj.objects[i].draw(i)
        }
    }

    function explorersInstinct() {
        if (!instincted) {
            let shaderData = mapFog.getImageData(0, 0, miniFog.width, miniFog.height)
            mapExplored = 0
            for (row = 0; row < shaderData.height; row++) {
                for (i = row * shaderData.width * 4; i < (row + 1) * shaderData.width * 4; i += 48) {
                    if (shaderData.data[i + 3] == 0) {
                        mapExplored++
                    }
                }
            }
            if (mapExplored > mapAreaTotal) {
                mapFog.fillStyle = "rgba(0, 0, 0, 0.5)"
                mapFog.fillRect(0, 0, miniFog.width, miniFog.height)
                mapFog.fillStyle = "rgba(0, 0, 0, 1)"
                instincted = true
            }
        }

    }

    function loop(timestamp) {
        progress = Math.min(timestamp - lastRender, 30);
        frameOn++
        if (!paused && gameStarted) {
            ctw.clearRect(0, 0, 2000, 2000)

            totalTime += progress / 1000
            timeInCurrentLevel += progress / 1000
            difficulty = totalTime / 300 + 1
            enemyMax = 15 + (4 * difficulty)

            update();
            draw();
            objects.globalCompositeOperation = "destination-out"
            objects.drawImage(lightsCanvas, 0, 0);
            objects.globalCompositeOperation = "source-over"
            ctx.drawImage(objectsCanvas, 0, 0, window.innerWidth / zoom, window.innerHeight / zoom, -scax / zoom, -scay / zoom, window.innerWidth / zoom, window.innerHeight / zoom);
            ctx.globalAlpha = brightness
            ctx.drawImage(lightsCanvas, 0, 0, window.innerWidth / zoom, window.innerHeight / zoom, -scax / zoom, -scay / zoom, window.innerWidth / zoom, window.innerHeight / zoom);
            ctx.globalAlpha = Math.max(brightness - 0.5, 0)
            ctx.fillStyle = "#14121d";
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight)
            ctx.globalAlpha = 1
            objects.clearRect(0, 0, objectsCanvas.width, objectsCanvas.height)
        }

        drawUI()

        lastRender = timestamp;
        window.requestAnimationFrame(loop);
    }

    function tutorial() {
        if (tutorialText[tutorialOn][1] == false) {
            playerMove();

            collectItemLoop();

            if ((tutorialOn == 3 || tutorialOn == 5) && shootLeft == true) {
                tutorialOn++;
            }

            if (tutorialOn == 9) {
                if (inputVector.w == 1) {
                    tutorialDirs.w = true;
                }
                if (inputVector.a == 1) {
                    tutorialDirs.a = true;
                }
                if (inputVector.s == 1) {
                    tutorialDirs.s = true;
                }
                if (inputVector.d == 1) {
                    tutorialDirs.d = true;
                }
                if (tutorialDirs.w == true &&
                    tutorialDirs.a == true &&
                    tutorialDirs.s == true &&
                    tutorialDirs.d == true
                ) {
                    tutorialOn++;
                }
            }

            if (tutorialOn == 11 && portalMadeForTutorial == false) {
                obj.collects.push({ x: (size.x / 2 + 9) * 50 + 25, y: 39 * 50 + 25, type: "exit", collect() { tutorialOn = 0; loadLevel() } })
                portalMadeForTutorial = true;
            }
        } else {
            shootLeft = false;
        }
        shootLoop();
    }

    function playerMove() {
        if (bioMass >= 100 && player.health < player.maxHealth) {
            bioMass = 0
            player.health = Math.min(player.health + 15, player.maxHealth)
        } else if (bioMass > 100) {
            bioMass = 100
        }

        let scaledSpeed = 0
        if (debugMode) {
            scaledSpeed = speed * progress * 4;
        } else {
            scaledSpeed = speed * progress;
        }

        if (rollTimer >= 0) {
            currentRollSpeed = evaluateBezier(rollSpeedCurve, -(rollTimer * 2.85714285714) + 1).y * 0.8
            rollTimer -= progress / 1000;
            addPos(0, currentRollSpeed * inputVector.y * progress, player);
            addPos(currentRollSpeed * inputVector.x * progress, 0, player);
            playerAnim.animOn = "roll"
        } else {
            addPos(inputVector.x * scaledSpeed, 0, player);
            addPos(0, inputVector.y * scaledSpeed, player);
            playerAnim.animOn = "run"
            playerWalkAudio.play()
        } if (inputVector.x == 0 && inputVector.y == 0) {
            playerAnim.animOn = "stand"
            playerWalkAudio.pause()

        }
        if (roll && rollCoolDownTimer <= 0) {
            rollTimer = rollTime;
            rollCoolDownTimer = rollCoolDown;
        }
        roll = false;
        rollCoolDownTimer -= progress / 1000;
        iFrameTimer -= progress / 1000;
    }

    function playerRender() {
        light(player.x, player.y, flashLightSize, 1);
        let f = [mouse.x - player.x + (scax / zoom), mouse.y - player.y + (scay / zoom)]
        let length = Math.sqrt((f[0] * f[0]) + (f[1] * f[1]));
        let units = unitVector(mouse.x - player.x + (scax / zoom), mouse.y - player.y + (scay / zoom));
        let rot = Math.atan2(units.y, units.x);
        let wideth = 140;
        //draw Light cone
        lights.beginPath();
        lights.fillStyle = "rgba(255, 255, 255, 1)";
        lights.moveTo(player.x + cam.x, player.y + cam.y);
        lights.arc(player.x + cam.x, player.y + cam.y, flashLightSize + length, rot - (wideth / length), rot + (wideth / length));
        lights.lineTo(player.x + cam.x, player.y + cam.y);
        lights.closePath();
        lights.fill();
    }

    function shootLoop() {
        aimPoint = { x: mouse.x + (scax / zoom), y: mouse.y + (scay / zoom), locked: false }
        if (aimLock) {
            minDist = 100
            for (i = 0; i < obj.enemies.length; i++) {
                dist = Math.sqrt(Math.pow((mouse.x - obj.enemies[i].x), 2) + Math.pow((mouse.y - obj.enemies[i].y), 2))
                if (dist < minDist) {
                    minDist = dist
                    aimPoint.x = obj.enemies[i].x
                    aimPoint.y = obj.enemies[i].y
                    aimPoint.locked = true;
                }
            }
        }

        slot = ["left"]//, "right"] //if you want left click to do something, the uncomment this bit.
        let units = unitVector(aimPoint.x - player.x, aimPoint.y - player.y);
        let rot = Math.atan2(units.y, units.x)
        for (i = 0; i < slot.length; i++) {
            isShooting = shootLeft
            if (i == 1) {
                isShooting = shootRight
            }
            type = gunValues[inventory[slot[i]].value];
            if (inventory[slot[i]].type == "gun") {
                gunValues[inventory[slot[i]].value].gunLoopFunction()
                if (isShooting && shootTimer <= 0 && type.energy > 0) {
                    camShake.shakeLevel = type.shake;
                    camShake.length = 0.2;
                    type.fireFunction(inventory[slot[i]].value, units, rot);
                } else {
                    type.finishFire()
                }
            } else if (inventory[slot[i]].type == "sword") {
                type = swordValues[inventory[slot[i]].value]
                if (isShooting && shootTimer <= 0) {
                    type.swingFunction(rot, units)
                }
            }
        }
        shootTimer -= progress / 1000;

        for (i = 0; i < obj.bullets.length; i++) {
            gunValues[obj.bullets[i].type].bulletFunction(obj.bullets[i], i)
        }
    }

    function enemyLoop() {
        if (obj.enemies.length < enemyMax && enemyTimer < 0) {
            let found = false;
            spawnType = null
            randomType = Math.random()
            if (randomType < 0.6) {
                spawnType = "rakamakra"
            } else if (randomType < 0.8) {
                spawnType = "bulletTurtle"
            } else if (randomType < 0.9) {
                spawnType = "frenziedRacoon"
            } else {
                spawnType = "cloneSlime"
            }
            spawnPos = { x: 0, y: 0 }
            for (failSafe = 0; !found && failSafe < 50; failSafe++) {
                spawnPos.y = clamp(Math.floor((Math.random() * 20) - 10 + (player.y / 50)), 0, loc.length - 1);
                spawnPos.x = clamp(Math.floor((Math.random() * 20) - 10 + (player.x / 50)), 0, loc[spawnPos.y].length - 1);
                enemyOn = false;
                for (i = 0; i < obj.enemies.length; i++) {
                    if (simpleCheckCol({ x: spawnPos.x * 50, y: spawnPos.y * 50 }, obj.enemies[i], 50)) enemyOn = true;
                }
                if (
                    loc[spawnPos.y][spawnPos.x] == false
                    && Math.abs((spawnPos.x * 50) - player.x) > 400
                    && Math.abs((spawnPos.y * 50) - player.y) > 400
                    && !enemyOn
                ) found = true;
            }
            if (found) {
                enemyValues[spawnType].spawnFunction(spawnType, spawnPos)
            }
        }
        if (enemyTimer > -0.5) enemyTimer -= progress / 1000;

        for (let i = 0; i < obj.enemies.length; i++) i -= enemyLogic(obj.enemies[i], i);
    }

    function collectItemLoop() {

        for (g = 0; g < obj.collects.length; g++) {
            let sheetParams = [tileSheet.ammoPickup, tileSheet.exit, tileSheet.gunPickup, tileSheet.key, tileSheet.money]
            let collectTypes = ["ammo", 'exit', 'gun', 'key', 'money']
            for (i = 0; i < collectTypes.length; i++) {
                if (obj.collects[g].type == collectTypes[i]) objects.drawImage(tileSheet.sheet, ...sheetParams[i], obj.collects[g].x - (obj.collects[g].width / 2) + cam.x, obj.collects[g].y - (obj.collects[g].height / 2) + cam.y, obj.collects[g].width, obj.collects[g].height);
            }
            if (obj.collects[g].type == "upgrade") animate(objects, obj.collects[g].x + cam.x - 21, obj.collects[g].y + cam.y - 24, obj.collects[g].anim, 42, 48)
            light(obj.collects[g].x, obj.collects[g].y, 125, 1);

            if (simpleCheckCol(obj.collects[g], player, 30)) {
                collect = obj.collects[g]
                obj.collects.splice(g, 1);
                collect.collect();
            }
        }
    }

    function enemyLogic(e, i) {
        scale = clamp(e.x - player.x, -1, 1)
        animate(objects, e.x - (e.width / 2) + cam.x, e.y - (e.height / 2) + cam.y, e.animations, e.width, e.height, scale, 1)
        if (simpleCheckCol(e, player, 800)) {
            enemyValues[e.type].loop(e, i)
        }

        if (Math.abs(e.x - player.x) > 1400 || Math.abs(e.y - player.y) > 1400) {
            obj.enemies.splice(i, 1);
            return 1;
        }

        if (obj.enemies[i]?.health < 0) {
            enemyTimer += 0.5 / (Math.abs(enemyTimer) + 0.1)
            obj.splatters.push({
                x: obj.enemies[i].x + (Math.random() * 10) - 5 - (scax / zoom),
                y: obj.enemies[i].y + (Math.random() * 10) - 5 - (scay / zoom),
                rotate: Math.random() * Math.PI * 2,
                fade: 6
            })
            obj.enemies.splice(i, 1);
            if (Math.random() > gunValues[inventory.left.value].energy / (gunValues[inventory.left.value].energy + gunValues[inventory.left.value].ammoDropRate)) obj.collects.push({ x: e.x, y: e.y, width: 20, height: 20, type: "ammo", collect() { gunValues[inventory.left.value].energy += gunValues[inventory.left.value].energyAdd } });

            obj.collects.push({ x: e.x + (Math.random() + 10) - 5, y: e.y + (Math.random() + 10) - 5, width: 20, height: 20, type: "money", collect() { money += this.money }, money: 10 });
            return 1;
        }
        return 0;
    }
    //MathFunctions
    function raycast(start, direction, checkForHits, rayCastLength, clipWalls) {
        if (!(checkForHits instanceof Array)) {
            checkForHits = [checkForHits]
        }
        let hit = false
        let endPoint = { x: 0, y: 0 };
        if (start == undefined) {
            start = player
        }
        let done = false;
        for (let i = 0; i < rayCastLength / 4; i++) {
            if (!done) {
                if (!clipWalls) {
                    if (
                        loc[clamp(Math.floor(((direction.y * 4 * i) + start.y) / 50), 0, loc.length - 1)][clamp(Math.floor(((direction.x * 4 * i) + start.x) / 50), 0, loc[0].length - 1)] == true
                    ) {
                        done = true;
                        endPoint = { x: (direction.x * 4 * i) + start.x, y: (direction.y * 4 * i) + start.y }
                    }
                }

                for (ii = 0; ii < checkForHits.length; ii++) {
                    if (simpleCheckCol({ x: (direction.x * 4 * i) + start.x, y: (direction.y * 4 * i) + start.y }, checkForHits[ii], 10)) {
                        hit = true
                    }
                }
            }

        }

        if (collisionDebug) {
            drawLine(ctw, start.x - (scax / zoom), start.y - (scay / zoom), endPoint.x - (scax / zoom), endPoint.y - (scay / zoom), "red", 1)
        }
        return hit
    }

    function evaluateBezier(p, t) {
        //credit to the Youtube channel Qixotl LFC for the code I reverse engineered to make bezier evaluation in this game.
        // the specific link is https://www.youtube.com/watch?v=7adUs4o2_JM
        let [p0, p1, p2, p3] = p;
        //Calculate the coefficients based on where the ball currently is in the animation
        let cx = 3 * (p1.x - p0.x);
        let bx = 3 * (p2.x - p1.x) - cx;
        let ax = p3.x - p0.x - cx - bx;
        let cy = 3 * (p1.y - p0.y);
        let by = 3 * (p2.y - p1.y) - cy;
        let ay = p3.y - p0.y - cy - by;
        //Calculate new X & Y positions of ball
        let xt = ax * (t * t * t) + bx * (t * t) + cx * t + p0.x;
        let yt = ay * (t * t * t) + by * (t * t) + cy * t + p0.y;
        //And return the value afterwards
        return { x: xt, y: yt }
    }

    function unitVector(x, y) {
        if (x?.x != undefined) {
            y = x.y
            x = x.x
        }
        let magnitude = Math.sqrt((x * x) + (y * y));
        return { x: x / magnitude, y: y / magnitude };
    }

    function magnitude(x, y) { return Math.sqrt((x * x) + (y * y)); }

    function negVector(vector) { return { x: -vector?.x, y: -vector?.y } }

    function vectorEquals(vec1, vec2) { return vec1?.x == vec2?.x && vec1?.y == vec2?.y && vec1?.x != undefined && vec2?.x != undefined }

    function addVector(vec1, vec2) { return { x: vec1.x + vec2.x, y: vec1.y + vec2.y } }

    function subtractVector(vec1, vec2) { return { x: vec1.x - vec2.x, y: vec1.y - vec2.y } }

    function clamp(num, min, max) { return Math.min(Math.max(num, min), max); }

    function clamp2(num, min, max, min1, max1) { return { x: Math.min(Math.max(num.x, min), max), y: Math.min(Math.max(num.y, min1), max1) }; }

    function distanceSquared(e, d) { return Math.pow((e.x - d.x), 2) + Math.pow((e.y - d.y), 2) }

    function distance(e, d) { return Math.sqrt(Math.pow((e.x - d.x), 2) + Math.pow((e.y - d.y), 2)) }
    //collision functions

    function addPos(x, y, e) {
        let viscosity = 1; // this is how much the thing will move. it's zero for a wall

        colKeys = Object.keys(triggerMap)
        for (let i = 0; i < colKeys.length; i++) {
            if (e.collision == colKeys[i]) {

                layers = triggerMap[colKeys[i]].layers
                solids = triggerMap[colKeys[i]].solids

                for (let j = 0; j < layers.length; j++) {
                    for (let k = 0; k < obj[layers[j]].length; k++) {
                        let g = obj[layers[j]][k]
                        colliding = checkCol(g, e, x, y);
                        if (colliding) {
                            if (solids.indexOf(layers[j]) != -1 && g?.solid != false) {
                                viscosity = 0
                            }
                            if (g?.solid == false || g?.solid == undefined) {
                                viscosity = e.onCollision?.(g, true) ?? viscosity
                            }
                            g.onCollision?.(e, true)
                        }
                    }
                }

                tiles = triggerMap[colKeys[i]].tiles
                solidTiles = triggerMap[colKeys[i]].solidTiles
                for (let j = 0; j < tiles.length; j++) {
                    hits = checkColToGrid(e, x, y, loc, tiles[j])
                    if (hits[0] || hits[1] || hits[2] || hits[3]) {
                        if (solidTiles.indexOf(tiles[j]) != -1) {
                            viscosity = 0
                        }
                        viscosity = e.onCollision?.(tiles[j], hits) ?? viscosity
                    }
                }
                i = colKeys.length
            }
        }

        e.y += y * viscosity
        e.x += x * viscosity
    }

    function checkCol(g, e, x, y) {
        if (Math.abs(g.x - e.x) > Math.abs(g.width + e.width) || Math.abs(g.y - e.y) > Math.abs(g.height + e.height)) return false;

        let [Ewidth, Eheight] = getColSize(e)
        let [Gwidth, Gheight] = getColSize(g)

        let [gpx, gpy] = getColliderCorners(g.x, g.y, Gwidth, Gheight, true)
        let [epx, epy] = getColliderCorners(e.x + x, e.y + y, Ewidth, Eheight)

        if (collisionDebug) {
            ctw.strokeStyle = "rgba(0, 255, 0, 1)"
            ctw.lineWidth = 1
            ctw.strokeRect(epx[1] + cam.x - (scax / zoom), epy[1] + cam.y - (scay / zoom), Ewidth, Eheight)
            ctw.strokeRect(gpx[0] + cam.x - (scax / zoom), gpy[0] + cam.y - (scay / zoom), Gwidth, Gheight)
        }

        for (let i = 0; i < gpx.length; i++) {
            for (let ii = 0; ii < gpy.length; ii++) {
                if (gpx[i] < epx[0] && gpx[i] > epx[1] && gpy[ii] < epy[0] && gpy[ii] > epy[1]) {
                    return { x: gpx[i], y: gpy[ii] };
                }
            }
        }
        for (let i = 0; i < epx.length; i++) {
            for (let ii = 0; ii < epy.length; ii++) {
                if (epx[i] > gpx[0] && epx[i] < gpx[1] && epy[ii] > gpy[0] && epy[ii] < gpy[1]) {
                    return { x: epx[i], y: epy[ii] };
                }
            }
        }
        return false;
    }

    function checkColToGrid(e, x, y, grid, tileToCheckFor) {
        let [Ewidth, Eheight] = getColSize(e)
        let [epx, epy] = getColliderCorners(e.x + x, e.y + y, Ewidth, Eheight)
        let hits = [false, false, false, false]
        index = 0
        for (let i = 0; i < epx.length; i++) {
            for (let ii = 0; ii < epy.length; ii++) {
                color = "red"
                if (grid?.[Math.floor(epy[ii] / 50)]?.[Math.floor(epx[i] / 50)] == tileToCheckFor) {
                    hits[index] = true
                    color = "green"
                }
                index++
                if (collisionDebug) {
                    //drawLine(ctw, (Math.floor(epx[i] / 50) * 50) - (scax / zoom), (Math.floor(epy[ii] / 50) * 50) - (scay / zoom), epx[i] - (scax / zoom), epy[ii] - (scay / zoom), color, 1)
                }
            }
        }
        return hits
    }

    function getColliderCorners(x, y, ew, ey, invert) { // invert is there because with the way collisions are checked, one of them has to have their corners listed in the reverse order, so if invert is defined as true then it will invert the order.
        corners = [[x + (ew / 2), x - (ew / 2)], [y + (ey / 2), y - (ey / 2)]]
        return (invert == true) ? [[corners[0][1], corners[0][0]], [corners[1][1], corners[1][0],]] : corners
    }

    function getColSize(e) { return [e?.colWidth || e?.width || 50, e?.colHeight || e?.height || 50] }

    function simpleCheckCol(e, d, s) { return Math.abs(e.x - d.x) < s && Math.abs(e.y - d.y) < s; }
    //canvas drawing functions
    function light(x, y, r, o) {
        lights.globalCompositeOperation = "destination-out"
        lights.lineWidth = 5;
        lights.beginPath();
        lights.fillStyle = "rgba(255, 255, 255, " + o + ")";
        lights.strokeStyle = "rgba(255, 255, 255, " + o + ")";
        lights.arc(x + cam.x, y + cam.y, r, 0, 2 * Math.PI, false);
        lights.fill();
        lights.stroke();
        lights.closePath();
    }

    function drawLine(ctx, sx, sy, ex, ey, color, width) {
        ctx.strokeStyle = color
        ctx.lineWidth = width
        ctx.beginPath()
        ctx.moveTo(cam.x + sx, cam.y + sy);
        ctx.lineTo(cam.x + ex, cam.y + ey);
        ctx.stroke();
    }

    function drawRotatedImage(image, x, y, angle, offsetX, offsetY, contx, w, h, sheetParams) {
        sheetParams = sheetParams || [0, 0, 0, 0]
        contx.save();
        contx.translate(x + cam.x, y + cam.y);
        contx.rotate(angle);
        contx.drawImage(image, ...sheetParams, -((w || image.width) / 2) + offsetX, -((h || image.height) / 2) + offsetY, w || image.width, h || image.height);
        contx.restore();
    }

    function imageSRC(src) {
        panimage = new Image();
        panimage.crossOrigin = null//"Anonymous";
        panimage.src = src;
        return panimage;
    }

    function animate(context, x, y, iobj, w, h, sx, sy) { // context is the canvas 2d context.
        if (iobj.animations[iobj.animOn]?.current == undefined) return

        sx = Math.round(sx) || 1
        sy = Math.round(sy) || 1
        context.save()
        context.scale(sx, sy);
        anim = iobj.animations[iobj.animOn]
        if (iobj.source != null) context.drawImage(iobj.source, Math.floor(iobj.animations[iobj.animOn].current) * anim.width + anim.sheetX, anim.sheetY, anim.width, anim.height, Math.round((x * sx) + (w * ((sx / 2) - 0.5))), Math.round(y * sy), w, h);
        iobj.animations[iobj.animOn].current = (anim.current + (1 / anim.speed * progress)) % anim.frames;
        if (iobj.animations[iobj.animOn].current < 0) iobj.animations[iobj.animOn].current = anim.frames;
        context.restore()
    }

    function start(tutorial) {
        openPage("dontActualyOpenAPage")
        if (tutorial) tutorialOn++;
        else levelLevel++;
        loadLevel();
    }

    draw();
    window.requestAnimationFrame(loop);
    window.addEventListener('resize', function () {
        zoom = 0.8 * (Math.max(window.innerWidth, window.innerHeight) / 1000);
        scax = (window.innerWidth - (window.innerWidth * zoom)) / 2
        scay = (window.innerHeight - (window.innerHeight * zoom)) / 2
    });
</script>

</html>

<script>
    /* Things to do/add for the game */
    /*
    19. sword knight
    22. shops
    26. make the second two shot johnson gun have some autolocking so it's more useful
    27. remove 4 shot susan, it's intriguing at first, but ultimately lame
    28. lazer focus needs a certain special something
    29. gauss gun should be more impactful
    31. make gun and bullets be able to have animations
    32. the cupid is kinda crappy, something needs to be done about it
    33. lazer weapons tend to be more powerful than a regular gun, they need to be balanced, or enemies just need to be harder
    35. make enemies less super angry
    37.
    */
    /*Things that the final game needs*/
    /*
    1. a shop and currency system
    //2. a full cast of weapons, including swords
    3. seven complete and finalized worlds
    4. 2 or 3 bosses
    5. a main menu
    6. a full cast of enemies

    list of things that need col functions:
    the player
    enemies
    crates
    bullets
    enemy bullets
    doors
    */
</script>